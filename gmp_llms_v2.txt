# gmp\_llms\_v2.txt

## 1\. Goal & Scope

**Primary Goal:** Guide Large Language Models (LLMs) to assist web developers in building modern, performant, secure, and cost-effective applications using the Google Maps Platform (GMP).

**Target Stack:**

* **JavaScript:** Vanilla ES2020+ (`async/await`, modules). Assume a single `index.html` unless otherwise specified.  
* **CSS:** Prefer Tailwind CSS (via CDN) \+ minimal inline `<style>` for specific map/marker element styling.  
* **HTML:** Standard HTML5.  
* **Focus:** Maps JavaScript API (core library and associated service libraries), **prioritizing Places API (New) and Routes API via `fetch`** where applicable, modern loading (`importLibrary`), API key security, release stage awareness, pricing considerations (Field Masks), and practical integration examples (2D Vector & 3D Photorealistic maps).  
* **Optional Advanced Libraries:** Include guidance for `loaders.gl` (data loading) and `deck.gl` (high-performance visualization on **2D maps only**) when requested or appropriate for large datasets.

**AI Role:** Provide accurate code examples, explain concepts, guide API selection (emphasizing modern APIs), enforce best practices (security, cost), and help troubleshoot common issues based *solely* on this context.

## 2\. API Selection Guide (Quick Reference)

* **Displaying Maps:**  
  * **Interactive 2D (Vector/Raster):** Maps JS API (`google.maps.Map`) \- Requires `mapId` for Vector/Advanced Markers.  
  * **Interactive 3D (Photorealistic):** Maps JS API (`Map3DElement`) \- Requires `v=alpha`. No `mapId`.  
  * **Simple Static Image:** Maps Static API (`<img>` tag).  
* **Place Search/Details:**  
  * **Standard Autocomplete UI Widget:** Maps JS API (`places` library \- `Autocomplete` class). *Note: Currently uses legacy backend but is the standard for this UI.* **Requires `fields` option for cost control.**  
  * **Programmatic Search/Details (Client or Server):** **PREFER Places API (New) via `fetch`** (Text Search, Nearby Search, Place Details endpoints). **Requires `X-Goog-FieldMask` header for cost control.**  
  * **Programmatic Details (Client-side, if Place ID known):** Maps JS API (`places` library \- `PlacesService.getDetails`). **Requires `fields` option for cost control.** (Alternative to `fetch` if JS library already loaded).  
  * **Place Details UI Component:** Maps JS API (`places` library \- `PlaceDetailsElement`). **Requires `v=alpha`**. Useful for displaying rich details without manual DOM manipulation. See Section 11\.  
* **Routing (Directions/Distance Matrix):**  
  * **All Use Cases (Client or Server):** **USE Routes API via `fetch`** (`computeRoutes`, `computeRouteMatrix`). **Requires `X-Goog-FieldMask` header for cost control.** *AVOID legacy Directions/Distance Matrix APIs/Services.*  
* **Address \<-\> Coordinates (Geocoding):**  
  * **Real-time User Input / Map Interaction:** Maps JS API (`geocoding` library \- `Geocoder`).  
  * **Backend / Batch Processing / Known Addresses:** Geocoding API (Web Service) via `fetch`.  
* **Address Validation (Deliverability Check):**  
  * **All Use Cases:** Address Validation API via `fetch`. *Use this specifically for validating deliverability, not just finding coordinates.*  
* **Elevation Data:**  
  * **Client-side / Interactive:** Maps JS API (`elevation` library \- `ElevationService`). **Essential for accurate 3D marker/camera placement.**  
  * **Backend / Batch:** Elevation API (Web Service) via `fetch`.  
* **Street View:**  
  * **Client-side / Interactive:** Maps JS API (`streetView` library \- `StreetViewService`, `StreetViewPanorama`).

## 3\. Core Principles & Best Practices (Enforce Vigorously)

* **Security First:** API Key security is PARAMOUNT. Always apply **HTTP Referrer** restrictions (for client-side JS) AND **API Restrictions** (least privilege). Never expose unrestricted keys. Use separate keys for different environments/apps.  
* **Modern Loading:** Use the **inline bootstrap loader** and `async/await google.maps.importLibrary()` for loading Maps JS API components. AVOID the legacy `libraries=` URL parameter.  
* **Prioritize Modern APIs:** Strongly prefer **Places API (New)** and **Routes API** (via `fetch`) over legacy counterparts or JS library services where feasible (except for the standard Autocomplete widget).  
* **Cost Control (Field Masks / `fields`):** This is **CRITICAL**.  
  * For **Places API (New)** and **Routes API** (via `fetch`), the `X-Goog-FieldMask` header is **MANDATORY**.  
  * For **Places JS Library** (`Autocomplete.getPlace()`, `PlacesService.getDetails()`, `Place.fetchFields()`), the `fields` option in the request is **MANDATORY**.  
  * **Only request the specific data fields needed.** Basic fields \= lower cost (Essentials SKUs).  
* **Release Stage Awareness:** Check API/feature release stages (GA, Preview, Experimental, Legacy). **AVOID Legacy APIs** entirely for new development. Use Preview/Experimental features with caution (no SLAs, potential changes) and primarily for testing.  
* **Coordinate Systems:** Be precise about formats:  
  * Maps JS API Elements (Markers, Polylines, Map center): `{ lat: number, lng: number }` (or `google.maps.LatLng`).  
  * Web Service APIs (`fetch` \- Places, Routes, etc.): Often return `{ latitude: number, longitude: number }`. **MUST BE CONVERTED** to `{ lat, lng }` for JS API.  
  * `deck.gl`: Typically expects `[longitude, latitude]`. **MUST BE CONVERTED**.  
* **Attribution:** Ensure Google Maps attribution is displayed correctly, especially when using Places data without a map.

## 4\. Setup: Google Cloud Platform Prerequisites

**Required Inputs (Get from User/Context):**

* `YOUR_API_KEY`: Google Cloud API Key with appropriate restrictions applied.  
* `YOUR_MAP_ID`: Map ID created in Google Cloud Console (REQUIRED for **2D Vector Maps** & **Advanced Markers**). *Not used for 3D maps.*

**Developer Actions (Must be completed):**

1. **Google Cloud Project:** Create or select a project.  
2. **Enable APIs:** Enable necessary APIs (e.g., "Maps JavaScript API", "Places API", "Routes API", "Geocoding API", "Address Validation API", "Elevation API") in the Cloud Console Library.  
3. **Billing Account:** Link a valid Cloud Billing account.

## 5\. API Key Management (CRITICAL FOR WEB)

* **Generation:** Create keys in GCP Console \> APIs & Services \> Credentials.  
* **Security Restrictions (MANDATORY):**  
  * **Application Restrictions:**  
    * **HTTP referrers:** ESSENTIAL for client-side JS keys. Restrict to specific domains (e.g., `*.yourdomain.com/*`, `localhost/*`).  
    * **IP addresses:** ONLY for server-side keys (backend use).  
  * **API Restrictions:** Limit the key to call ONLY the specific GMP APIs needed (e.g., "Maps JavaScript API", "Places API").  
* **Best Practices:** Use separate keys (dev/staging/prod), apply *both* restriction types tightly, never commit keys, monitor usage.

## 6\. Maps JavaScript API Loading (Modern Standard)

**Inline Bootstrap Loader (Include ONCE in HTML `<head>`):**

```html
<script>
  (g=>{var h,a,k,p="The Google Maps JavaScript API",c="google",l="importLibrary",q="__ib__",m=document,b=window;b=b[c]||(b[c]={});var d=b.maps||(b.maps={}),r=new Set,e=new URLSearchParams,u=()=>h||(h=new Promise(async(f,n)=>{await(a=m.createElement("script"));e.set("libraries",[...r]+"");for(k in g)e.set(k.replace(/[A-Z]/g,t=>"_"+t.toLowerCase()),g[k]);e.set("callback",c+".maps."+q);a.src=`https://maps.${c}apis.com/maps/api/js?`+e;d[q]=f;a.onerror=()=>h=n(Error(p+" could not load."));a.nonce=m.querySelector("script[nonce]")?.nonce||"";m.head.append(a)}));d[l]?console.warn(p+" only loads once. Ignoring:",g):d[l]=(f,...n)=>r.add(f)&&u().then(()=>d[l](f,...n))})({
    key: "YOUR_API_KEY", // Replace with actual API key
    // v: "weekly", // Default channel (stable GA features)
    v: "beta", // RECOMMENDED for latest GA features, 2D Vector Maps, Elevation, StreetView, etc.
    // v: "alpha", // Use ONLY for 3D Maps or specific Experimental features (e.g., UI Kits)
    // language: "en", // Optional: Language code (e.g., "en", "es")
    // region: "US", // Optional: Region code (e.g., "US", "GB")
  });
</script>
```

**Dynamic Library Import (Inside async JS functions):**

```javascript
// --- Load Core Map & Marker Libraries ---
async function loadCoreMapLibs() {
  const [{ Map }, { AdvancedMarkerElement, PinElement }, { LatLng, LatLngBounds }] = await Promise.all([
    google.maps.importLibrary("maps"),      // Core 2D map, InfoWindow, Polyline, Polygon
    google.maps.importLibrary("marker"),    // Advanced Markers (2D/3D), PinElement, CollisionBehavior
    google.maps.importLibrary("core")       // LatLng, LatLngBounds, MVCObject, etc.
  ]);
  return { Map, AdvancedMarkerElement, PinElement, LatLng, LatLngBounds };
}

// --- Load Places Library (for Autocomplete Widget, PlacesService, Place Class, PlaceDetailsElement) ---
async function loadPlacesLibs() {
  const { Autocomplete, PlacesService, Place, PlaceDetailsElement } = await google.maps.importLibrary("places");
  return { Autocomplete, PlacesService, Place, PlaceDetailsElement };
}

// --- Load Other Service Libraries (as needed) ---
async function loadServiceLibs(services = []) { // e.g., ['geocoding', 'elevation', 'geometry', 'streetView']
    const loadedLibs = {};
    const promises = services.map(async (libName) => {
        const lib = await google.maps.importLibrary(libName);
        // Assign specific classes/modules you need from the library
        if (libName === 'geocoding') loadedLibs.Geocoder = lib.Geocoder;
        if (libName === 'elevation') loadedLibs.ElevationService = lib.ElevationService;
        if (libName === 'geometry') { loadedLibs.encoding = lib.encoding; loadedLibs.spherical = lib.spherical; loadedLibs.poly = lib.poly; }
        if (libName === 'streetView') { loadedLibs.StreetViewService = lib.StreetViewService; loadedLibs.StreetViewPanorama = lib.StreetViewPanorama; }
        // Add other libraries as needed
    });
    await Promise.all(promises);
    return loadedLibs;
}

// --- Load 3D Map Libraries (Requires v=alpha in loader) ---
async function load3DMapLibs() {
  const [{ Map3DElement, MapMode, AltitudeMode }, { Marker3DElement, Marker3DInteractiveElement, Polyline3DElement, Polygon3DElement }] = await Promise.all([
      google.maps.importLibrary("maps3d"), // Core 3D map element and modes
      google.maps.importLibrary("maps3d")  // 3D-specific elements (Marker3D, Polyline3D, Polygon3D)
  ]);
  // CollisionBehavior is shared, load via "marker" if needed
  const { CollisionBehavior } = await google.maps.importLibrary("marker");
  return { Map3DElement, MapMode, AltitudeMode, Marker3DElement, Marker3DInteractiveElement, Polyline3DElement, Polygon3DElement, CollisionBehavior };
}

// --- Example Usage ---
async function initializeApp() {
  try {
    const { Map, AdvancedMarkerElement } = await loadCoreMapLibs();
    const { Autocomplete } = await loadPlacesLibs();
    const { Geocoder } = await loadServiceLibs(['geocoding']);
    // ... rest of initialization ...
  } catch (error) { console.error("Failed to load libraries:", error); }
}
```

## 7\. Core Maps JavaScript API Components

### 7.1. 2D Maps (`google.maps.Map` \- Vector/Raster)

* **Library:** `maps`  
* **Release Stage:** GA  
* **Initialization:** Requires container `<div>`. `mapId` is REQUIRED for Vector maps & Advanced Markers.

```javascript
// Assumes 'Map' class is imported
const mapContainer = document.getElementById('map');
const map = new Map(mapContainer, {
  center: { lat: -34.397, lng: 150.644 },
  zoom: 8,
  mapId: "YOUR_MAP_ID", // *** REQUIRED for Vector/Advanced Markers ***
  disableDefaultUI: true, // Example: Hide default controls
  //zoomControl: true,
  //mapTypeControl: false,
  //streetViewControl: false,
  //gestureHandling: "greedy", // Or `cooperative` if user asks for no auto zoom
});
```

### `7.2.` 3D Maps (`google.maps.maps3d.Map3DElement` \- Photorealistic)

* **Library:** `maps3d`  
* **Release Stage:** Alpha (Requires `v=alpha` in loader)  
* **Initialization:** Web Component, append to DOM. NO `mapId`. Requires center with altitude.

```javascript
// Assumes 'Map3DElement', 'MapMode' imported
const mapContainer = document.getElementById('map-container'); // Container div
const map3d = new Map3DElement({
    center: { lat: 40.75, lng: -74.00, altitude: 100 }, // *** Altitude REQUIRED ***
    range: 1000, // Distance from camera to center in meters
    tilt: 65,    // Camera angle (0=straight down, 90=horizon)
    heading: -45, // Compass direction (0=North)
    mode: MapMode.HYBRID, // Or MapMode.SATELLITE
    defaultUIDisabled: true, // to disable controls, recommended
    // Optional restrictions:
    // minAltitude: 50, maxAltitude: 10000,
    // minTilt: 0, maxTilt: 75,
    
});
mapContainer.innerHTML = ''; // Clear container
mapContainer.appendChild(map3d); // Add to DOM
```

* **3D Camera Control:** Use `map3d.flyCameraTo({ endCamera: {...}, durationMillis: N })`, `map3d.flyCameraAround({ camera: {...}, durationMillis: N, rounds: N })`, `map3d.stopCameraAnimation()`.

```javascript
// Example: Fly camera to a new location
async function flyToLocation(map3dInstance, targetCoords, range, tilt, heading, duration = 1500) {
    if (!map3dInstance) return;
    const endCamera = { center: targetCoords, range, tilt, heading };
    try {
        await map3dInstance.flyCameraTo({ endCamera, durationMillis: duration });
        console.log("Fly-to animation complete.");
    } catch (error) {
        if (error.name === 'AbortError' || error.message?.includes('interrupted')) {
           console.log("Camera animation interrupted.");
        } else { console.error("flyCameraTo error:", error); }
    }
}
// Usage:
// const target = { lat: 35.6586, lng: 139.7454, altitude: 500 }; // Tokyo Tower area
// flyToLocation(map3d, target, 1000, 60, 0);
```

* **3D Events:** Use `element.addEventListener('gmp-click', handler)`, `element.addEventListener('gmp-steadychange', handler)`, etc. Distinguish `LocationClickEvent` (click on map terrain/water) vs `PlaceClickEvent` (click on POI).

```javascript
// Example: Handle clicks on the 3D map
map3d.addEventListener('gmp-click', (event) => {
    if (event.detail?.placeId) { // PlaceClickEvent (POI clicked)
        console.log('Clicked Place ID:', event.detail.placeId);
        // Optionally fetch place details: event.fetchPlace().then(place => ...);
        // Optionally show PlaceDetailsElement: showPlaceDetails(event.detail.placeId);
    } else if (event.detail?.position) { // LocationClickEvent (Map clicked)
        console.log('Clicked Map Location:', event.detail.position); // {lat, lng, altitude}
    }
});
```

## 8\. Key JS API Features & Elements

### 8.1. Markers (Points on Map)

* **2D: `AdvancedMarkerElement`**  
  * **Library:** `marker` | **Release:** GA | **Requires:** `mapId` on Map.  
  * **Position:** `{ lat: number, lng: number }`. CONVERT from API responses if needed. Altitude can be provided for vector maps but is less common than in 3D.  
  * **Interaction:**  
    * `gmpClickable: true` (requires `v=beta` or later) enables `gmp-click` event. Use `marker.addEventListener('gmp-click', handler)`.  
    * `addListener('click', handler)` is the older way (still works).  
    * `gmpDraggable: true` enables dragging events (`dragstart`, `drag`, `dragend`). Use `addListener` for these.  
  * **Customization:**  
    * Default: Red pin.  
    * `PinElement`: Customizable background, border, glyph (text/icon), scale.  
    * Any HTML Element: Style with CSS (e.g., Tailwind). Use `marker.content` or `marker.appendChild()`.  
  * **Collision:** `collisionBehavior: google.maps.CollisionBehavior.OPTIONAL_AND_HIDES_LOWER_PRIORITY` (or `REQUIRED`, `REQUIRED_AND_HIDES_OPTIONAL`). Higher `zIndex` gives priority.  
  * **Web Component:** `<gmp-advanced-marker position="lat,lng" title="..."></gmp-advanced-marker>`.

```javascript
// Assumes 'AdvancedMarkerElement', 'PinElement', 'CollisionBehavior' imported
// Assumes 'map' is 2D Map instance with mapId

// Basic clickable marker (using addEventListener)
const basicMarker = new AdvancedMarkerElement({
  map,
  position: { lat: -34.397, lng: 150.644 },
  title: "Basic Marker",
  gmpClickable: true, // Use addEventListener('gmp-click', ...)
});
basicMarker.addEventListener('gmp-click', () => { /* Show InfoWindow */ });

// Draggable marker (using addListener)
const draggableMarker = new AdvancedMarkerElement({
  map,
  position: { lat: -34.45, lng: 150.5 },
  title: "Drag Me",
  gmpDraggable: true,
  zIndex: 10, // Higher priority
});
draggableMarker.addListener('dragend', (event) => {
  const newPos = draggableMarker.position; // Get updated LatLngAltitudeLiteral
  console.log('Dragged to:', newPos.lat, newPos.lng);
});

// Custom PinElement marker
const customPin = new PinElement({
  background: '#FBBC04', // Yellow
  borderColor: '#000',
  glyph: '★', // Star icon
  glyphColor: '#000',
  scale: 1.5,
});
const pinMarker = new AdvancedMarkerElement({
  map,
  position: { lat: -34.4, lng: 150.7 },
  content: customPin.element, // Use the element property
  title: "Custom Pin",
  collisionBehavior: CollisionBehavior.OPTIONAL_AND_HIDES_LOWER_PRIORITY,
});

// Custom HTML marker (Tailwind example)
const priceTag = document.createElement('div');
priceTag.className = 'price-tag bg-blue-600 text-white text-xs px-2 py-1 rounded shadow';
priceTag.textContent = '$50';
const htmlMarker = new AdvancedMarkerElement({
  map,
  position: { lat: -34.4, lng: 150.8 },
  content: priceTag, // Directly assign the HTML element
  title: "Price Tag",
});
```

* **3D: `Marker3DElement` / `Marker3DInteractiveElement`**  
  * **Library:** `maps3d` | **Release:** Alpha (`v=alpha`)  
  * **Position:** `{ lat, lng, altitude }`. Altitude is required. Use `ElevationService` for ground altitude if needed (see example).  
  * **Altitude Mode:** `altitudeMode` property controls how altitude is interpreted:  
    * `AltitudeMode.CLAMP_TO_GROUND`: Ignores altitude, places on terrain/water surface. (Default)  
    * `AltitudeMode.RELATIVE_TO_GROUND`: Altitude is height above terrain/water surface.  
    * `AltitudeMode.ABSOLUTE`: Altitude is height above mean sea level (WGS84 EGM96 geoid). **Use with ElevationService.**  
    * `AltitudeMode.RELATIVE_TO_MESH`: Altitude is height above highest surface (terrain, building, water).  
  * **Valid Content:**  
    * Default pin (if no content provided).  
    * `PinElement`: Customizable pin (background, glyph, etc.). Assign to `marker.appendChild(pinElement)`.  
    * `<template>` with single `<img>` or `<svg>`: Wrap image/SVG in `<template>` and assign to `marker.appendChild(templateElement)`. Note: Images/SVGs are rasterized; complex CSS/embedded HTML might not render. Other HTML content will cause errors.  
  * **Interaction:**  
    * Use `Marker3DInteractiveElement` for click events.  
    * Listen using `marker.addEventListener('gmp-click', handler)`.  
    * Use `marker.dataset.yourId = 'value'` to store custom data, accessible via `event.target.dataset.yourId`.  
  * **Other Properties:** `collisionBehavior` (shared with 2D), `extruded` (line to ground, requires relative/absolute altitude), `drawsWhenOccluded`, `sizePreserved`, `label`, `zIndex`.  
  * **Web Component:** `<gmp-marker-3d ...>`, `<gmp-marker-3d-interactive ...>`.

````javascript
// Assumes 'Marker3DElement', 'Marker3DInteractiveElement', 'AltitudeMode' imported from "maps3d"
// Assumes 'PinElement', 'CollisionBehavior' imported from "marker"
// Assumes 'map3d' is Map3DElement instance
// Assumes 'getClientElevation' function exists (see Section 9.3)

async function add3DMarkers() {
  const targetLocation = { lat: 40.751, lng: -74.002 };
  const groundElevation = await getClientElevation(targetLocation);
  const baseAltitude = groundElevation ?? 10; // Fallback altitude if elevation fails

  // Interactive Marker with Custom Pin, Relative to Ground
  const pin3D = new PinElement({ background: '#DB4437', glyph: '★', scale: 1.2 });
  const interactiveMarker = new Marker3DInteractiveElement({
    position: { ...targetLocation, altitude: baseAltitude + 15 }, // 15m above ground
    altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
    collisionBehavior: CollisionBehavior.OPTIONAL_AND_HIDES_LOWER_PRIORITY,
    // label: "Click Me", // Optional text label
  });
  interactiveMarker.appendChild(pin3D); // Add pin content
  interactiveMarker.dataset.pointId = 'poi-1'; // Store custom data
  interactiveMarker.addEventListener('gmp-click', (e) => {
    console.log('3D Marker Click:', e.target.dataset.pointId);
    console.log('Clicked Position:', e.target.position); // {lat, lng, altitude}
    // Example: Show details panel based on clicked marker's data
    // showDetailsPanel(e.target.dataset.pointId);
  });
  map3d.appendChild(interactiveMarker); // Add to map

  // Non-interactive Marker with Absolute Altitude (using ElevationService) and Extrusion
  const absoluteMarker = new Marker3DElement({
      position: { lat: 40.752, lng: -74.003, altitude: baseAltitude + 100 }, // 100m above ground at this specific location
      altitudeMode: AltitudeMode.ABSOLUTE, // Use ABSOLUTE with elevation data
      extruded: true, // Draw line to ground
      // Default pin appearance
  });
  map3d.appendChild(absoluteMarker);

  // Marker Clamped to Ground (Altitude ignored)
  const clampedMarker = new Marker3DElement({
      position: { lat: 40.750, lng: -74.001, altitude: 5000 }, // Altitude ignored
      altitudeMode: AltitudeMode.CLAMP_TO_GROUND,
  });
  map3d.appendChild(clampedMarker);

  // Marker with Image Content (using template)
  const imageTemplate = document.createElement('template');
  imageTemplate.innerHTML = `<img src="path/to/your/icon.png" style="width: 32px; height: 32px; object-fit: contain;">`;
  const imageMarker = new Marker3DElement({
      position: { lat: 40.753, lng: -74.004, altitude: baseAltitude + 20 }, // 20m above ground
      altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
      sizePreserved: true, // Keep icon size constant regardless of zoom
  });
  imageMarker.appendChild(imageTemplate.content.cloneNode(true)); // Append cloned template content
  map3d.appendChild(imageMarker);
}```

### 8.2. Drawing on Map (Lines & Areas)
*   **2D: `google.maps.Polyline`, `google.maps.Polygon`**
    *   **Library:** `maps` | **Release:** GA
    *   **Path:** Array of `{ lat, lng }`.
    *   **Options:** `strokeColor`, `strokeWeight`, `fillColor`, `fillOpacity`, `geodesic: true`.

```javascript
// Assumes 'map' is 2D Map instance
// Assumes 'Polyline' imported from "maps"
const routePath = [{ lat: 37.77, lng: -122.44 }, { lat: 37.77, lng: -122.40 }];
const polyline = new google.maps.Polyline({
  path: routePath,
  strokeColor: "#FF0000",
  strokeOpacity: 0.8,
  strokeWeight: 4,
  geodesic: true, // Follow earth curvature
  map: map
});
````

* **3D: `Polyline3DElement`, `Polygon3DElement`**  
  * **Library:** `maps3d` | **Release:** Alpha (`v=alpha`)  
  * **Coordinates:** Array of `{ lat, lng, altitude }`. Use `ElevationService` or fetch from Routes API. `altitudeMode`.  
  * **Extrusion:** `extruded: true` (connects shape to ground).  
  * **Other Options:** `strokeColor`, `strokeWidth`, `fillColor` (Polygon), `geodesic`, `zIndex`.

```javascript
// Assumes 'Polyline3DElement', 'AltitudeMode' imported
// Assumes 'map3d' is Map3DElement instance
// Assumes 'coords3D' is [{lat, lng, altitude}, ...] (e.g., from Routes API + Elevation)

const line3D = new Polyline3DElement({
  coordinates: coords3D,
  strokeColor: 'yellow',
  strokeWidth: 5,
  altitudeMode: AltitudeMode.ABSOLUTE, // Or RELATIVE_TO_GROUND, etc.
  geodesic: true,
  // extruded: true, // Optional: Connect to ground
  zIndex: 1,
});
map3d.appendChild(line3D); // Add to map
```

### 8.3. Info Windows (2D Maps Only)

* **Library:** `maps` | **Release:** GA  
* **Purpose:** Popup anchored to `AdvancedMarkerElement`.  
* **Content:** HTML string or DOM Node. Use `domready` event for async content.

```javascript
// Assumes 'map' is 2D Map, 'basicMarker' is AdvancedMarkerElement
// Assumes 'InfoWindow' imported from "maps"
const infoWindow = new google.maps.InfoWindow();

basicMarker.addEventListener('gmp-click', () => {
  // Create content dynamically or use existing element
  const contentDiv = document.createElement('div');
  contentDiv.innerHTML = `
    <h3 class="text-lg font-semibold">${basicMarker.title}</h3>
    <p>Position: ${basicMarker.position.lat.toFixed(4)}, ${basicMarker.position.lng.toFixed(4)}</p>
    <button id="info-btn" class="mt-2 px-2 py-1 bg-blue-500 text-white rounded text-xs">More Info</button>
  `;
  infoWindow.setContent(contentDiv);
  infoWindow.open({ map: map, anchor: basicMarker });

  // Optional: Add listener after content is in DOM
  google.maps.event.addListenerOnce(infoWindow, 'domready', () => {
      document.getElementById('info-btn')?.addEventListener('click', () => {
          console.log('Info button clicked for marker:', basicMarker.title);
      });
  });
});

// Close InfoWindow when map is clicked
map.addListener('click', () => infoWindow.close());
```

## 9\. Essential JS API Services (Client-Side Logic)

### 9.1. Places Library Services

* **Library:** `places`  
* **Release Stage:** GA (Autocomplete/PlacesService use Legacy backend per docs; check status). UI Kits Experimental (`v=alpha`).  
* **Autocomplete Widget:** `google.maps.places.Autocomplete`  
  * **Use Case:** Standard UI for place input.  
  * **CRITICAL:** Use `fields` option (e.g., `['place_id', 'geometry', 'name']`) for cost control on `getPlace()`.  
  * **Listen for `place_changed`**, call `autocomplete.getPlace()`.

```javascript
// Assumes 'Autocomplete' imported
// Assumes 'map' is 2D/3D map instance
const inputElement = document.getElementById('autocomplete-input');
const autocomplete = new Autocomplete(inputElement, {
    fields: ["place_id", "geometry", "name", "formatted_address", "types"], // *** MANDATORY for cost control ***
    types: ['geocode'], // Example: Restrict to geocoding results
});
// autocomplete.bindTo("bounds", map); // Optional: Bias results to map viewport
autocomplete.addListener('place_changed', () => {
    const place = autocomplete.getPlace(); // Returns PlaceResult object
    if (!place.place_id || !place.geometry?.location) {
        console.warn("Autocomplete: No details available for input: '" + inputElement.value + "'");
        return;
    }
    console.log("Selected Place:", place.name, place.place_id);
    // Use place.geometry.location (LatLng) for map actions
    // centerMapOnPlace(place); addMarkerForPlace(place);
});
```

* **Place Details Service:** `google.maps.places.PlacesService`  
  * **Use Case:** Programmatic details fetch using Place ID (client-side alternative to fetch). Prefer `fetch` with Places API (New) unless JS library is already needed.  
  * **Attribution:** Requires HTML element in constructor: `new PlacesService(mapDiv)`.  
  * **CRITICAL:** Use `fields` option in `getDetails({ placeId, fields: [...] }, callback)` for cost control.

```javascript
// Assumes 'PlacesService', 'PlacesServiceStatus' imported
// Assumes 'mapDiv' exists
const placesService = new google.maps.places.PlacesService(mapDiv); // mapDiv for attribution

function fetchJsPlaceDetails(placeId) {
  const request = {
      placeId: placeId,
      fields: ['name', 'rating', 'website', 'opening_hours', 'photos'] // *** MANDATORY for cost control ***
  };
  placesService.getDetails(request, (place, status) => { // place is PlaceResult
    if (status === google.maps.places.PlacesServiceStatus.OK && place) {
      console.log("JS PlacesService Details:", place);
      // Update UI with place.name, place.rating, etc.
    } else {
      console.error("PlacesService failed:", status);
      showError(`Could not fetch place details: ${status}`);
    }
  });
}
```

* **Place Class:** `google.maps.places.Place`  
  * **Use Case:** Fetch additional fields if you already have a Place object instance (e.g., from `PlaceClickEvent` on 3D map).  
  * **CRITICAL:** Use `fields` option in `place.fetchFields({ fields: [...] })` for cost control.

```javascript
// Assumes 'Place' imported
// Example: placeObject could come from map3d PlaceClickEvent.fetchPlace()
async function fetchExtraJsDetails(placeObject) {
    if (!placeObject?.id) return; // Need Place ID
    try {
        await placeObject.fetchFields({ fields: ['reviews', 'businessStatus', 'priceLevel'] }); // *** MANDATORY for cost control ***
        console.log("Fetched extra JS details:", placeObject.reviews, placeObject.businessStatus);
        // Update UI
    } catch (error) {
        console.error("Failed to fetch extra Place fields:", error);
        showError("Could not fetch additional place details.");
    }
}

// Example usage with 3D Map click event
// map3d.addEventListener('gmp-click', async (event) => {
//   if (event.detail?.placeId) { // Check if it's a PlaceClickEvent
//     try {
//       const place = await event.fetchPlace(); // Gets Place instance with ID
//       console.log("Fetched initial place:", place.id);
//       await fetchExtraJsDetails(place); // Fetch more fields
//     } catch (error) { console.error("Error fetching place from click:", error); }
//   }
// });
```

* **Place Details Element:** `<gmp-place-details>` (Web Component) or `google.maps.places.PlaceDetailsElement` (JS Class)  
  * **Library:** `places` | **Release:** Alpha (`v=alpha`)  
  * **Use Case:** Display rich, pre-formatted place details UI. Requires a Place ID.  
  * **Initialization:** Add `<gmp-place-details>` to HTML or create JS instance.  
  * **Configuration:** Use `element.configureFromPlace({ id: placeId })`.

```javascript
// --- HTML ---
// <div id="details-panel" style="display: none;">
//   <button id="close-details-btn">Close</button>
//   <gmp-place-details size="MEDIUM" id="place-details-widget"></gmp-place-details>
// </div>

// --- JavaScript ---
// Assumes 'PlaceDetailsElement' imported from "places"
// Assumes 'placeDetailsWidget' is reference to <gmp-place-details> element
// Assumes 'detailsPanel' is reference to the container div
// Assumes 'closeDetailsBtn' is reference to the close button

async function showPlaceDetails(placeId) {
    if (!placeDetailsWidget || !placeId) return;
    detailsPanel.style.display = 'block'; // Show the container
    try {
        // Configure the widget with the place ID
        await placeDetailsWidget.configureFromPlace({ id: placeId });
        console.log("Place Details configured for:", placeId);
    } catch (error) {
        console.error(`Place Details config error for ${placeId}:`, error);
        placeDetailsWidget.innerHTML = `<p>Could not load details. Error: ${error.message}</p>`;
    }
}

function hidePlaceDetails() {
    if (detailsPanel) detailsPanel.style.display = 'none';
}

// closeDetailsBtn.addEventListener('click', hidePlaceDetails);

// Example Usage (e.g., on marker click):
// marker.addEventListener('gmp-click', () => showPlaceDetails(marker.dataset.placeId));
```

### 9.2. Geocoding Service (`google.maps.Geocoder`)

* **Library:** `geocoding` | **Release:** GA  
* **Use Case:** Client-side address \<-\> coordinate conversion (user input, map clicks). Prefer Geocoding API (Web Service) via `fetch` for backend/batch.  
* **Method:** `await geocoder.geocode({ address: '...' })` or `await geocoder.geocode({ location: {lat, lng} })`. Returns `{ results }`.

```javascript
// Assumes 'Geocoder' imported
const geocoder = new google.maps.Geocoder();

// Address -> LatLng
async function geocodeAddressClient(address) {
  try {
    const { results } = await geocoder.geocode({ address: address });
    if (results?.[0]?.geometry.location) {
      console.log("Geocoded Location:", results[0].formatted_address, results[0].geometry.location.toJSON());
      return results[0]; // Returns GeocoderResult
    } else {
      console.warn("Geocoding failed or no results for:", address);
      return null;
    }
  } catch (e) {
    console.error("Geocode failed:", e);
    showError(`Geocoding error: ${e.message}`);
    return null;
  }
}

// LatLng -> Address (Reverse Geocoding)
async function reverseGeocodeClient(latLng) { // latLng is {lat, lng}
  try {
    const { results } = await geocoder.geocode({ location: latLng });
    if (results?.[0]) {
      console.log("Reverse Geocoded Address:", results[0].formatted_address);
      return results[0]; // Returns GeocoderResult
    } else {
      console.warn("Reverse geocoding failed or no results for:", latLng);
      return null;
    }
  } catch (e) {
    console.error("Reverse geocode failed:", e);
    showError(`Reverse geocoding error: ${e.message}`);
    return null;
  }
}
// Example: map.addListener('click', (e) => reverseGeocodeClient(e.latLng.toJSON()));
```

### 9.3. Elevation Service (`google.maps.ElevationService`)

* **Library:** `elevation` | **Release:** GA  
* **Use Case:** Client-side elevation lookup. Essential for accurate 3D placement (`AltitudeMode.RELATIVE_TO_GROUND` or calculating `ABSOLUTE`).  
* **Methods:** `await elevator.getElevationForLocations({ locations: [...] })`, `await elevator.getElevationAlongPath({ path: [...], samples: N })`. Returns `{ results }`.

```javascript
// Assumes 'ElevationService' imported
const elevator = new google.maps.ElevationService();

// Get elevation for a single point
async function getClientElevation(latLng) { // latLng is {lat, lng} or LatLng object
  try {
    const { results } = await elevator.getElevationForLocations({ locations: [latLng] });
    if (results?.[0]?.elevation != null) { // Check for null/undefined explicitly
      console.log(`Elevation at ${latLng.lat}, ${latLng.lng}: ${results[0].elevation.toFixed(2)}m`);
      return results[0].elevation; // Elevation in meters above sea level (WGS84 EGM96 geoid)
    } else {
      console.warn("Elevation query returned no results or null elevation for:", latLng);
      return null;
    }
  } catch (e) {
    console.error("Elevation failed:", e);
    showError(`Elevation lookup error: ${e.message}`);
    return null;
  }
}

// Get elevation profile along a path (batching for efficiency)
async function getPathElevations(pathLatLngs, numSamples = 100) { // pathLatLngs is [{lat, lng}, ...] or [LatLng, ...]
  if (!pathLatLngs || pathLatLngs.length < 2) return null;
  try {
    const { results } = await elevator.getElevationAlongPath({
        path: pathLatLngs,
        samples: numSamples
    });
    if (results) {
        console.log(`Elevation profile (${results.length} samples):`, results.map(r => r.elevation.toFixed(1)));
        return results; // Array of ElevationResult objects
    } else {
        console.warn("Elevation path query returned no results.");
        return null;
    }
  } catch (e) {
    console.error("Elevation path failed:", e);
    showError(`Elevation path lookup error: ${e.message}`);
    return null;
  }
}

// Batch elevation requests for multiple points (more efficient than single requests)
async function getElevationsForPoints(locations) { // locations is array of {lat, lng} or LatLng
    if (!elevator || locations.length === 0) return locations.map(() => 10); // Default if no service or locations
    const batchSize = 200; // Max locations per request (adjust if needed)
    let allElevations = [];
    for (let i = 0; i < locations.length; i += batchSize) {
        const batchLocations = locations.slice(i, i + batchSize);
        try {
            const { results } = await elevator.getElevationForLocations({ locations: batchLocations });
            const elevations = results.map(result => result?.elevation ?? 10); // Use default if elevation is null/undefined
            allElevations.push(...elevations);
        } catch (e) {
            console.error(`Elevation fetch error for batch starting at index ${i}:`, e);
            // Fill with defaults for the failed batch
            allElevations.push(...Array(batchLocations.length).fill(10));
        }
    }
    return allElevations;
}
```

### 9.4. Street View Service (`google.maps.StreetViewService`, `google.maps.StreetViewPanorama`)

* **Library:** `streetView` | **Release:** GA  
* **Use Case:** Find and display Street View imagery in a `<div>`.  
* **Methods:** `streetViewService.getPanorama({ location / panoId }, callback)`, `streetViewPanorama.setPano(panoId)`.

```javascript
// Assumes 'StreetViewService', 'StreetViewPanorama' imported
// Assumes 'svPanoDiv' is the container <div> in HTML
let streetViewService;
let streetViewPanorama;

function initStreetView(containerElement) {
    streetViewService = new google.maps.StreetViewService();
    streetViewPanorama = new google.maps.StreetViewPanorama(containerElement, {
        position: { lat: 40.7580, lng: -73.9855 }, // Initial position (optional)
        pov: { heading: 34, pitch: 10 },
        zoom: 1,
        visible: false, // Initially hidden
        motionTracking: false, // Disable device orientation controls
        motionTrackingControl: false,
    });
    // Add listeners to the panorama itself if needed
    // streetViewPanorama.addListener('position_changed', () => { ... });
}

function showStreetViewNear(latLng) {
    if (!streetViewService || !streetViewPanorama) {
        console.error("Street View not initialized.");
        return;
    }
    const request = {
        location: latLng,
        radius: 50, // Search within 50 meters
        source: google.maps.StreetViewSource.OUTDOOR, // Prefer outdoor imagery
        preference: google.maps.StreetViewPreference.NEAREST, // Find closest panorama
    };

    streetViewService.getPanorama(request, (data, status) => {
        if (status === google.maps.StreetViewStatus.OK) {
            console.log("Street View found:", data.location.pano);
            streetViewPanorama.setPano(data.location.pano);
            streetViewPanorama.setVisible(true);
            // Optionally update POV if needed
            // streetViewPanorama.setPov({ heading: 270, pitch: 0 });
        } else {
            console.warn("Street View not found near location.", status);
            streetViewPanorama.setVisible(false);
            showError("Street View imagery not available here.");
        }
    });
}

// --- Initialization ---
// const svPanoDiv = document.getElementById('street-view-pano');
// initStreetView(svPanoDiv);

// --- Usage Example ---
// map.addListener('click', (e) => {
//   showStreetViewNear(e.latLng.toJSON());
// });
// Or call directly: showStreetViewNear({ lat: 40.7580, lng: -73.9855 }); // Times Square
```

## 10\. Key Web Service APIs (Server-Side / `fetch`)

**General:** Prefer calling these from a backend proxy to protect API keys. If calling from client-side `fetch`, strict HTTP Referrer restrictions are MANDATORY. Always handle potential errors and check response status.

### 10.1. Places API (New) \- via `fetch`

* **Release Stage:** GA | **PREFER THIS** for programmatic search/details.  
* **Auth:** `X-Goog-Api-Key` header.  
* **Cost:** `X-Goog-FieldMask` header **REQUIRED**.  
* **Coordinates:** Returns `{ latitude, longitude }`. **CONVERT** for JS API.  
* **Endpoints:**  
  * Text Search: `POST https://places.googleapis.com/v1/places:searchText` (Body: `{ textQuery: '...' }`)  
  * Nearby Search: `POST https://places.googleapis.com/v1/places:searchNearby` (Body: `{ includedTypes: ['...'], locationRestriction: { circle: {...} } }`)  
  * Place Details: `GET https://places.googleapis.com/v1/places/{PLACE_ID}`  
  * Search Along Route: `POST https://places.googleapis.com/v1/places:searchText` (Body: `{ textQuery: '...', searchAlongRouteParameters: { polyline: { encodedPolyline: '...' } } }`)

```javascript
// --- Fetch Example (Text Search) ---
async function searchPlacesFetch(query, apiKey) {
  const url = 'https://places.googleapis.com/v1/places:searchText';
  const headers = {
    'Content-Type': 'application/json',
    'X-Goog-Api-Key': apiKey,
    // *** REQUIRED FieldMask for cost control and data selection ***
    'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.location,places.types,places.rating,places.userRatingCount'
  };
  const body = JSON.stringify({
      textQuery: query,
      maxResultCount: 10,
      // languageCode: 'en', // Optional
      // regionCode: 'US', // Optional
  });

  try {
    showLoading(true, "Searching places...");
    const response = await fetch(url, { method: 'POST', headers, body });

    if (!response.ok) {
      // Try to get more specific error details from the response body
      let errorDetails = response.statusText;
      try {
          const errorData = await response.json();
          errorDetails = errorData.error?.message || JSON.stringify(errorData);
      } catch (e) { /* Ignore if body isn't JSON */ }
      throw new Error(`Search failed (${response.status}): ${errorDetails}`);
    }

    const data = await response.json();
    console.log("Fetch Search Results:", data.places);

    // Process results: Add markers (CONVERT coords!), update list
    // Example marker position:
    // if (place.location) {
    //   const position = { lat: place.location.latitude, lng: place.location.longitude };
    //   addMarker(position, place.displayName);
    // }
    return data.places || [];
  } catch (error) {
    console.error('Search fetch error:', error);
    showError(error.message);
    return [];
  } finally {
    showLoading(false);
  }
}

// --- Fetch Example (Place Details) ---
async function getPlaceDetailsFetch(placeId, apiKey) {
    const url = `https://places.googleapis.com/v1/places/${placeId}`;
    const headers = {
        'Content-Type': 'application/json',
        'X-Goog-Api-Key': apiKey,
        // *** REQUIRED FieldMask ***
        'X-Goog-FieldMask': 'id,displayName,formattedAddress,location,websiteUri,regularOpeningHours,photos'
    };

    try {
        showLoading(true, "Fetching details...");
        const response = await fetch(url, { method: 'GET', headers });
        if (!response.ok) { /* ... (similar error handling as above) ... */ throw new Error(`Details fetch failed (${response.status})`); }
        const placeDetails = await response.json();
        console.log("Fetch Place Details:", placeDetails);
        // Update UI with details
        return placeDetails;
    } catch (error) { /* ... (error handling) ... */ return null; }
    finally { showLoading(false); }
}
```

### 10.2. Routes API \- via `fetch`

* **Release Stage:** GA | **USE THIS** for all routing. AVOID legacy APIs.  
* **Auth:** `X-Goog-Api-Key` header.  
* **Cost:** `X-Goog-FieldMask` header **REQUIRED**.  
* **Coordinates:** Leg locations use `{ latLng: { latitude, longitude } }`. **CONVERT** for JS API markers.  
* **Polyline:** Decode `routes.polyline.encodedPolyline` using JS geometry library.  
* **Endpoints:**  
  * `POST https://routes.googleapis.com/directions/v2:computeRoutes`  
  * `POST https://routes.googleapis.com/distanceMatrix/v2:computeRouteMatrix`

```javascript
// --- Fetch Example (Compute Routes) ---
async function fetchRoute(origin, destination, apiKey) {
  // origin/destination can be:
  // { placeId: '...' }
  // { address: '...' }
  // { location: { latLng: { latitude: ..., longitude: ... } } }
  const url = 'https://routes.googleapis.com/directions/v2:computeRoutes';
  const headers = {
    'Content-Type': 'application/json',
    'X-Goog-Api-Key': apiKey,
    // *** REQUIRED FieldMask ***
    'X-Goog-FieldMask': 'routes.duration,routes.distanceMeters,routes.polyline.encodedPolyline,routes.legs.startLocation,routes.legs.endLocation,routes.legs.steps.startLocation,routes.legs.steps.endLocation,routes.description'
  };
  const body = JSON.stringify({
      origin: origin,
      destination: destination,
      travelMode: "DRIVE", // Or "WALK", "BICYCLE", "TWO_WHEELER"
      routingPreference: "TRAFFIC_AWARE", // Or "TRAFFIC_UNAWARE"
      computeAlternativeRoutes: false,
      // units: "METRIC", // Or "IMPERIAL"
      // languageCode: "en-US"
  });

  try {
    showLoading(true, "Calculating route...");
    const response = await fetch(url, { method: 'POST', headers, body });

    if (!response.ok) {
      // Try to get more specific error details from the response body
      let errorDetails = response.statusText;
      try {
          const errorData = await response.json();
          errorDetails = errorData.error?.message || JSON.stringify(errorData);
      } catch (e) { /* Ignore if body isn't JSON */ }
      throw new Error(`Route fetch failed (${response.status}): ${errorDetails}`);
    }

    const data = await response.json();

    if (data.routes?.[0]) {
      console.log("Route found:", data.routes[0]);
      // displayRouteOnMap(data.routes[0]); // Call your client-side display function
      return data.routes[0]; // Return the first route object
    } else {
      showError("No route found between the specified locations.");
      return null;
    }
  } catch (error) {
    console.error('Route fetch error:', error);
    showError(error.message);
    return null;
  } finally {
    showLoading(false);
  }
}

// --- Client-side Display Helper (2D Map Example) ---
// Keep references to map objects for easy clearing
let routePolyline2D = null;
let startMarker2D = null;
let endMarker2D = null;

async function displayRouteOn2DMap(route, mapInstance) {
  if (!mapInstance || !route?.polyline?.encodedPolyline) {
      console.error("Map not ready or route data incomplete.");
      return null;
  }

  // Clear previous route objects
  routePolyline2D?.setMap(null);
  startMarker2D?.setMap(null);
  endMarker2D?.setMap(null);

  try {
    // Load necessary libraries if not already loaded
    const { encoding } = await google.maps.importLibrary("geometry");
    const { Polyline } = await google.maps.importLibrary("maps");
    const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");
    const { LatLng, LatLngBounds } = await google.maps.importLibrary("core");

    // Decode polyline
    const decodedPath = encoding.decodePath(route.polyline.encodedPolyline); // Returns array of LatLng objects

    // Create Polyline
    routePolyline2D = new Polyline({
      path: decodedPath,
      strokeColor: '#1a73e8', strokeOpacity: 0.8, strokeWeight: 5,
      map: mapInstance,
    });

    // Create Start/End Markers (Convert coordinates!)
    const startLatLng = route.legs?.[0]?.startLocation?.latLng;
    const endLatLng = route.legs?.[route.legs.length - 1]?.endLocation?.latLng;

    if (startLatLng) {
        startMarker2D = new AdvancedMarkerElement({
            position: { lat: startLatLng.latitude, lng: startLatLng.longitude },
            map: mapInstance, title: 'Route Start',
        });
    }
    if (endLatLng) {
        endMarker2D = new AdvancedMarkerElement({
            position: { lat: endLatLng.latitude, lng: endLatLng.longitude },
            map: mapInstance, title: 'Route End',
        });
    }

    // Fit map bounds to the route
    const bounds = new LatLngBounds();
    decodedPath.forEach(point => bounds.extend(point));
    if (startMarker2D) bounds.extend(startMarker2D.position);
    if (endMarker2D) bounds.extend(endMarker2D.position);

    if (!bounds.isEmpty()) mapInstance.fitBounds(bounds, 100); // Add padding

    console.log(`Route displayed: ${route.distanceMeters}m, ${route.duration}`);
    // Return references for potential future clearing
    return { polyline: routePolyline2D, startMarker: startMarker2D, endMarker: endMarker2D };

  } catch (error) {
      console.error("Error displaying route on 2D map:", error);
      showError("Could not display the calculated route.");
      // Clean up partially created objects if error occurred mid-way
      routePolyline2D?.setMap(null); startMarker2D?.setMap(null); endMarker2D?.setMap(null);
      return null;
  }
}

// --- Client-side Display Helper (3D Map Example) ---
let routePolyline3D = null; // Store reference to clear later

async function displayRouteOn3DMap(route, map3dInstance) {
    if (!map3dInstance || !route?.polyline?.encodedPolyline) {
        console.error("3D Map not ready or route data incomplete.");
        return;
    }
    // Clear previous route
    routePolyline3D?.remove();
    routePolyline3D = null;

    try {
        // Load necessary libraries
        const { encoding } = await google.maps.importLibrary("geometry");
        const { Polyline3DElement, AltitudeMode } = await google.maps.importLibrary("maps3d");
        const { LatLngBounds } = await google.maps.importLibrary("core");

        // Decode path (array of LatLng)
        const decodedPathLatLng = encoding.decodePath(route.polyline.encodedPolyline);

        // Get elevations for the path points
        const elevations = await getElevationsForPoints(decodedPathLatLng); // Use batching helper from 9.3

        // Create path with altitude
        const pathWithAltitude = decodedPathLatLng.map((point, index) => ({
            lat: point.lat(),
            lng: point.lng(),
            altitude: elevations[index] ?? 10 // Use fetched elevation or default
        }));

        // Create 3D Polyline
        routePolyline3D = new Polyline3DElement({
            coordinates: pathWithAltitude,
            strokeColor: '#1a73e8', strokeWidth: 8,
            altitudeMode: AltitudeMode.ABSOLUTE, // Altitudes are absolute
            map: map3dInstance, // Add directly to map
        });
        map3dInstance.appendChild(routePolyline3D);

        // Fit camera to bounds (optional, similar logic to 2D but uses flyCameraTo)
        const bounds = new LatLngBounds();
        decodedPathLatLng.forEach(point => bounds.extend(point));
        if (!bounds.isEmpty()) {
            // flyToRouteBounds(bounds); // Implement flyToRouteBounds for 3D if needed
        }
        console.log(`3D Route displayed: ${route.distanceMeters}m, ${route.duration}`);

    } catch (error) {
        console.error("Error displaying route on 3D map:", error);
        showError("Could not display the calculated 3D route.");
        routePolyline3D?.remove(); // Clean up if error
    }
}
```

### 10.3. Geocoding API (Web Service) \- via `fetch`

* **Release Stage:** GA  
* **Use Case:** Backend/batch geocoding. AVOID for real-time user input (use JS Geocoder).  
* **Endpoint:** `GET https://maps.googleapis.com/maps/api/geocode/json`  
* **Params:** `address=...` or `latlng=...`, `key=...`.  
* **Response:** JSON with `results` (incl. `geometry.location {lat, lng}`) and `status`.

```javascript
// --- Fetch Example (Forward Geocoding - Address to LatLng) ---
async function geocodeAddressServer(address, apiKey) {
  const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${apiKey}`;
  try {
    showLoading(true, "Geocoding address...");
    const response = await fetch(url);
    if (!response.ok) { /* ... (error handling) ... */ throw new Error(`Geocoding fetch failed (${response.status})`); }
    const data = await response.json();

    if (data.status === 'OK' && data.results?.[0]) {
        console.log("Server Geocode Result:", data.results[0].formatted_address, data.results[0].geometry.location);
        return data.results[0]; // Return GeocoderResult object
    } else {
        console.warn(`Server Geocoding failed: ${data.status}`, data.error_message);
        showError(`Could not geocode address: ${data.status}`);
        return null;
    }
  } catch (error) {
    console.error('Server geocode error:', error);
    showError(error.message);
    return null;
  } finally {
    showLoading(false);
  }
}
```

### 10.4. Address Validation API \- via `fetch`

* **Release Stage:** GA  
* **Use Case:** Validate address deliverability (checkout, shipping). Not for general geocoding.  
* **Endpoint:** `POST https://addressvalidation.googleapis.com/v1:validateAddress`  
* **Auth:** `X-Goog-Api-Key` header.  
* **Body:** `{ address: { regionCode: 'US', addressLines: [...] }, ... }`. `regionCode` required.  
* **Response:** JSON with `result.verdict`, `result.address`, `result.geocode`.

```javascript
// --- Fetch Example ---
async function validateAddressFetch(addressObject, apiKey) {
  // addressObject example:
  // {
  //   regionCode: 'US',
  //   languageCode: 'en',
  //   addressLines: ['1600 Amphitheatre Parkway', 'Mountain View', 'CA', '94043']
  // }
  const url = `https://addressvalidation.googleapis.com/v1:validateAddress?key=${apiKey}`; // Key can be in URL or header
  const headers = {
      'Content-Type': 'application/json',
      // 'X-Goog-Api-Key': apiKey, // Alternative to key in URL
  };
  const body = JSON.stringify({
      address: addressObject,
      // enableUspsCass: true // Optional: For CASS certification (US only)
  });

  try {
    showLoading(true, "Validating address...");
    const response = await fetch(url, { method: 'POST', headers, body });

    if (!response.ok) {
      // Try to get more specific error details from the response body
      let errorDetails = response.statusText;
      try {
          const errorData = await response.json();
          errorDetails = errorData.error?.message || JSON.stringify(errorData);
      } catch (e) { /* Ignore if body isn't JSON */ }
      throw new Error(`Validation failed (${response.status}): ${errorDetails}`);
    }

    const data = await response.json();
    console.log('Validation Result:', data.result);
    console.log('Verdict:', data.result?.verdict);
    console.log('Address Components:', data.result?.address?.addressComponents);
    console.log('Geocode Location:', data.result?.geocode?.location); // {latitude, longitude}

    // Check verdict flags like:
    // data.result.verdict.hasUnconfirmedComponents
    // data.result.verdict.addressComplete
    // data.result.verdict.hasInferredComponents
    // data.result.address.missingComponentTypes

    return data.result; // Return the result object
  } catch (error) {
    console.error('Validation fetch error:', error);
    showError(`Address validation error: ${error.message}`);
    return null;
  } finally {
    showLoading(false);
  }
}
```

### 10.5. Other Web Services (Elevation, Environment, Static Maps, Tiles)

* Refer to specific API documentation for endpoints and parameters. Use `fetch` (or `<img>` for Static Maps). Remember API Key and potential restrictions.

## 11\. Experimental / Preview Features (Use with Caution)

* **Places UI Components (`v=alpha`):** `<gmp-place-picker>`, `<gmp-place-data-provider>`, `<gmp-place-overview>`, `<gmp-place-details>`. Check docs for usage and required libraries (`places`). See Section 9.1 for `PlaceDetailsElement` example.  
* **Air Quality Meter (`v=alpha`):** `<gmp-air-quality-meter>`. Requires `airquality` library.  
* **Web Components (`v=beta`/GA):** `<gmp-map>`, `<gmp-advanced-marker>`. Alternative HTML declaration for core elements.

## 12\. Data Loading & Visualization (Optional Libraries)

Use these for handling larger datasets or creating advanced visualizations, primarily on 2D maps.

### 12.1. Data Loading Strategy

* **Simple Formats (GeoJSON, JSON arrays):** `deck.gl` layers often handle direct loading via the `data` prop (e.g., passing a fetched JSON array to `ScatterplotLayer`). While some layers support passing URLs directly to the `data` prop (e.g., `GeoJsonLayer`), **it is strongly recommended to use explicit `fetch` to load external data.** This allows for better error handling (checking `response.ok`, validating the response format) and provides more control over the loading process, significantly aiding debugging. Use direct data assignment (passing the fetched array/object) for simpler cases.  
* **Complex Formats / Pre-processing (CSV, KML, binary, large files):** Use `loaders.gl` for robust parsing and handling before passing the processed data array to `deck.gl` layers.

### 12.2. `deck.gl` (High-Performance Visualization \- 2D Maps Only)

* **Purpose:** WebGL-powered visualization layers for large datasets (points, lines, polygons, heatmaps, hexbins, etc.). Integrates with Google Maps 2D ONLY via `GoogleMapsOverlay`.  
* **CDN:** `<script src="https://unpkg.com/deck.gl@latest/dist.min.js"></script>`, `<script src="https://unpkg.com/@deck.gl/google-maps@latest/dist.min.js"></script>`. (May need additional layer modules like `@deck.gl/layers`, `@deck.gl/aggregation-layers`, etc. depending on usage).  
* **Usage:**  
  * Initialize the overlay: `const deckOverlay = new deck.GoogleMapsOverlay({ layers: [] });`  
  * Link to the `google.maps.Map` instance: `deckOverlay.setMap(mapInstance);` (where `mapInstance` is your 2D map).  
  * Update layers dynamically: `deckOverlay.setProps({ layers: [ newLayer1, newLayer2, ... ] });`  
  * **CRITICAL: Verify Layer Classes:** After loading deck.gl scripts (core, layers, google-maps, etc.), always verify that the specific layer classes you intend to use (e.g., `window.deck.ScatterplotLayer`, `window.deck.GeoJsonLayer`) are defined *before* calling their constructors. This prevents errors if a required layer module failed to load or wasn't included.  
  * **Use `window.deck` Prefix:** For clarity and to avoid potential scoping issues, explicitly reference deck.gl classes via the global `window` object (e.g., `new window.deck.ScatterplotLayer(...)`, `new window.deck.GoogleMapsOverlay(...)`).  
  * **IMPORTANT TIMING:** Ensure the `GoogleMapsOverlay` is instantiated and linked (`deckOverlay.setMap(mapInstance)`) only *after* the `google.maps.Map` instance (`mapInstance`) is fully initialized and ready. Using the map's `idle` event listener once is a reliable way to ensure the map is ready before adding the overlay. Similarly, only update layers (`deckOverlay.setProps`) after the overlay is set on the map and you have data ready.  
* **Coordinate Format:** Most layers expect `getPosition`, `getPath`, `getPolygon` etc. accessors to return coordinates in **`[longitude, latitude]`** order. **CRITICAL:** Convert data if necessary.  
* **Interaction:** Enable via `pickable: true`. Use `onHover`, `onClick`, `autoHighlight: true`, and `getTooltip: ({object}) => ...` for user feedback.  
* **Performance:** Use `updateTriggers` prop to fine-tune when accessors are recalculated. Consider `Fp64Extension` for high-precision coordinate systems if needed (requires `extensions` prop).  
* **Dynamic Properties:** Use functions for accessors (`getRadius`, `getFillColor`) to style features based on their properties (e.g., earthquake magnitude). Update the `updateTriggers` prop when the property being visualized changes.

**Common Layer Categories & Examples:** (Refer to `gmp_llms_v2.txt` for detailed list)

**Example: Scatterplot Layer Integration (Minimal)**

```javascript
// Assumes deck.gl core, layers, and google-maps overlay are loaded globally
// Assumes 'map' is 2D google.maps.Map instance
// Assumes 'myData' is array of { longitude: number, latitude: number, magnitude: number }
// Assumes 'tooltipDiv' exists in HTML for hover info

let deckOverlay; // Store overlay instance

function initializeDeckGlOverlay(mapInstance) {
    if (!window.deck || !window.deck.GoogleMapsOverlay) {
      console.warn("deck.gl libraries not loaded."); return;
    }
    deckOverlay = new deck.GoogleMapsOverlay({ layers: [] });
    deckOverlay.setMap(mapInstance);
}

function updateDeckLayers(data) {
  if (!deckOverlay || !data) return;

  const scatterLayer = new deck.ScatterplotLayer({
    id: 'data-scatter',
    data: data,
    // *** COORDINATE ORDER: [longitude, latitude] ***
    getPosition: d => [d.longitude, d.latitude],
    // Style based on data properties (example: magnitude)
    getRadius: d => Math.max(1, d.magnitude) * 10, // Radius based on magnitude
    getFillColor: d => d.magnitude > 5 ? [255, 0, 0, 180] : [255, 140, 0, 150], // Red/Orange
    radiusUnits: 'meters',
    radiusMinPixels: 1, radiusMaxPixels: 40,
    // Interaction
    pickable: true, autoHighlight: true,
    onHover: handleDeckHover, // Tooltip function
    onClick: (info) => { // Example click handler
        if (info.object) console.log('Clicked:', info.object);
    }
  });

  deckOverlay.setProps({ layers: [scatterLayer] });
}

// --- Tooltip Handling ---
function handleDeckHover({object, x, y}) {
    const tooltipDiv = document.getElementById('tooltip'); // Get tooltip div
    if (!tooltipDiv) return;
    if (object) {
        tooltipDiv.style.left = `${x}px`; tooltipDiv.style.top = `${y}px`;
        tooltipDiv.innerHTML = `
            <strong>Magnitude:</strong> ${object.magnitude?.toFixed(1) ?? 'N/A'}<br>
            <strong>Location:</strong> ${object.latitude?.toFixed(3)}, ${object.longitude?.toFixed(3)}
        `;
        tooltipDiv.style.display = 'block';
    } else {
        tooltipDiv.style.display = 'none';
    }
}

// --- Initialization & Data Loading ---
// async function start() {
//   await init2DMap(); // Assuming this initializes the 'map' variable
//   initializeDeckGlOverlay(map);
//   const data = await loadData(); // Your data loading function
//   if(data) updateDeckLayers(data);
// }
// start();
```

## 13\. UI & Interaction Patterns

* **Sidebar \<-\> Map Linking:** Use unique IDs (`data-point-id`) on list items and markers/data. On click, find counterpart and trigger actions (pan/fly, highlight, show details).

```javascript
// --- HTML List Item ---
// <li data-marker-id="poi-123">Point Of Interest</li>

// --- JS Event Listener (Sidebar) ---
sidebarList.addEventListener('click', (event) => {
    if (event.target.tagName === 'LI' && event.target.dataset.markerId) {
        const markerId = event.target.dataset.markerId;
        const marker = markersMap.get(markerId); // Get marker from state (see below)
        if (marker) {
            // Highlight list item (add/remove CSS class)
            highlightListItem(event.target);
            // Trigger map action
            if (map instanceof google.maps.Map) { // 2D
                map.panTo(marker.position);
                // Optionally open InfoWindow
            } else if (map instanceof google.maps.maps3d.Map3DElement) { // 3D
                flyToLocation(map, marker.position, 1000, 60, 0); // Use flyTo helper
            }
        }
    }
});
```

* **Loading/Error Feedback:** Use simple divs toggled via JS. Provide informative error messages, potentially including details from API error responses.

```javascript
// --- HTML ---
// <div id="loading-indicator" style="display: none;">Loading...</div>
// <div id="error-message" style="display: none; color: red;"></div>

// --- JS Utility Functions ---
const loadingIndicator = document.getElementById('loading-indicator');
const errorMessageDiv = document.getElementById('error-message');

function showLoading(isLoading, text = "Loading...") {
    if (!loadingIndicator) return;
    loadingIndicator.textContent = text;
    loadingIndicator.style.display = isLoading ? 'block' : 'none';
    if (isLoading) showError(''); // Clear errors when loading starts
}

function showError(message) {
    if (!errorMessageDiv) return;
    errorMessageDiv.textContent = message || ''; // Clear if message is empty/null
    errorMessageDiv.style.display = message ? 'block' : 'none';
}
```

* **Info Panel Toggle:** Show/hide a details panel (like for `PlaceDetailsElement` or custom info).

```javascript
// --- HTML ---
// <div id="details-panel" style="display: none;">... content ...</div>

// --- JS ---
const detailsPanel = document.getElementById('details-panel');

function showDetailsPanel(content) { // content could be data object or HTML string
    // Populate panel content here...
    if (detailsPanel) detailsPanel.style.display = 'block';
}

function hideDetailsPanel() {
    if (detailsPanel) detailsPanel.style.display = 'none';
}
// Example: detailsPanel.querySelector('.close-button').addEventListener('click', hideDetailsPanel);
```

* **State Management:** For simple apps, use module-level variables (`map`, `apiKey`, `markers = []`). For managing multiple map objects (markers, lines), use a `Map` object for easy access, updates, or removal by ID.

```javascript
// --- JS State Management Example ---
let map; // Holds the map instance (2D or 3D)
let activeMarkers = new Map(); // Use a Map to store markers by unique ID (e.g., placeId)

async function addOrUpdateMarker(position, title, id) {
    if (!map || !position || !id) return;
    const markerId = id;

    // Remove existing marker with the same ID if it exists
    if (activeMarkers.has(markerId)) {
        const existingMarker = activeMarkers.get(markerId);
        if (map instanceof google.maps.Map) { // 2D
            existingMarker.setMap(null);
        } else if (map instanceof google.maps.maps3d.Map3DElement) { // 3D
            map.removeChild(existingMarker); // Use removeChild for 3D elements
        }
        activeMarkers.delete(markerId);
    }

    // Create and add the new marker (adapt for 2D/3D as shown in Section 8.1)
    let newMarker;
    if (map instanceof google.maps.Map) {
        const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");
        newMarker = new AdvancedMarkerElement({ position, map, title });
        // Add 2D listeners...
    } else {
        const { Marker3DInteractiveElement } = await google.maps.importLibrary("maps3d");
        // Get elevation...
        newMarker = new Marker3DInteractiveElement({ position: { ...position, altitude: 10 }, /* ... */ });
        map.appendChild(newMarker);
        // Add 3D listeners...
    }

    // Store the new marker reference
    activeMarkers.set(markerId, newMarker);
    console.log(`Marker ${markerId} added/updated. Total markers: ${activeMarkers.size}`);
}

function removeMarker(markerId) {
    if (activeMarkers.has(markerId)) {
        const marker = activeMarkers.get(markerId);
         if (map instanceof google.maps.Map) marker.setMap(null);
         else if (map instanceof google.maps.maps3d.Map3DElement) map.removeChild(marker);
        activeMarkers.delete(markerId);
        console.log(`Marker ${markerId} removed.`);
    }
}

function clearAllMarkers() {
    activeMarkers.forEach((marker, id) => {
        if (map instanceof google.maps.Map) marker.setMap(null);
        else if (map instanceof google.maps.maps3d.Map3DElement) map.removeChild(marker);
    });
    activeMarkers.clear();
    console.log("All markers cleared.");
}
```

## 14\. HTML/CSS Template (Tailwind \+ Floating Sidebar)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Maps App</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
    <!-- Optional: Add deck.gl/loaders.gl CDN links here if needed -->
    <!-- <script src="https://unpkg.com/deck.gl@latest/dist.min.js"></script> -->
    <!-- <script src="https://unpkg.com/@deck.gl/google-maps@latest/dist.min.js"></script> -->
    <!-- <script src="https://unpkg.com/@deck.gl/layers@latest/dist.min.js"></script> -->
    <!-- <script src="https://unpkg.com/@loaders.gl/csv@latest/dist/dist.min.js"></script> -->
    <style>
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; }
        #map-container { height: 100%; width: 100%; position: relative; } /* Ensure relative positioning for absolute children */
        #map { height: 100%; width: 100%; background-color: #e5e7eb; }
        gmp-map-3d { display: block; height: 100%; width: 100%; } /* For 3D */
        .sidebar-content::-webkit-scrollbar { width: 6px; }
        .sidebar-content::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 3px; }
        .pac-container { z-index: 1051 !important; } /* Autocomplete dropdown above sidebar */
        .list-item { padding: 8px 12px; border-bottom: 1px solid #e5e7eb; cursor: pointer; transition: background-color 0.15s; }
        .list-item:hover { background-color: #f3f4f6; }
        .list-item.selected { background-color: #dbeafe; font-weight: 500; }
        #tooltip { font-size: 0.75rem; background: rgba(0,0,0,0.8); color: white; padding: 4px 8px; border-radius: 4px; position: fixed; /* Use fixed for viewport positioning */ z-index: 1060; /* Above map and sidebar */ pointer-events: none; display: none; white-space: pre-wrap; max-width: 300px; }
        #street-view-pano { height: 40%; width: 100%; position: absolute; bottom: 0; left: 0; z-index: 5; border-top: 2px solid #ccc; display: none; /* Initially hidden */ }
        /* Basic Info Panel Style */
        #details-panel { position: absolute; top: 1rem; right: 1rem; background: white; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 20; max-width: 300px; display: none; /* Initially hidden */ }
        #details-panel .close-button { position: absolute; top: 0.25rem; right: 0.5rem; background: none; border: none; font-size: 1.2rem; cursor: pointer; }
    </style>
    <!-- Google Maps API Loader (Update v=beta/alpha as needed) -->
    <script>
      (g=>{var h,a,k,p="The Google Maps JavaScript API",c="google",l="importLibrary",q="__ib__",m=document,b=window;b=b[c]||(b[c]={});var d=b.maps||(b.maps={}),r=new Set,e=new URLSearchParams,u=()=>h||(h=new Promise(async(f,n)=>{await(a=m.createElement("script"));e.set("libraries",[...r]+"");for(k in g)e.set(k.replace(/[A-Z]/g,t=>"_"+t.toLowerCase()),g[k]);e.set("callback",c+".maps."+q);a.src=`https://maps.${c}apis.com/maps/api/js?`+e;d[q]=f;a.onerror=()=>h=n(Error(p+" could not load."));a.nonce=m.querySelector("script[nonce]")?.nonce||"";m.head.append(a)}));d[l]?console.warn(p+" only loads once. Ignoring:",g):d[l]=(f,...n)=>r.add(f)&&u().then(()=>d[l](f,...n))})({
        key: "YOUR_API_KEY", // *** REPLACE ***
        v: "beta", // Use "beta" for 2D, "alpha" for 3D/Experimental
        // map_ids: "YOUR_MAP_ID", // Can also specify mapId here
      });
    </script>
</head>
<body class="relative h-screen overflow-hidden antialiased text-gray-800">

    <!-- Map Container -->
    <div id="map-container" class="absolute inset-0 z-0">
       <div id="map"></div> <!-- Target for 2D map -->
       <!-- Map3DElement appended here for 3D -->
       <div id="tooltip"></div> <!-- Tooltip for deck.gl -->
       <div id="street-view-pano"></div> <!-- Container for Street View -->
       <!-- Example Details Panel -->
       <div id="details-panel">
           <button class="close-button" onclick="hideDetailsPanel()">×</button>
           <h3 id="details-title" class="text-lg font-semibold mb-2">Details</h3>
           <div id="details-content">Panel content goes here...</div>
           <!-- Example: Container for PlaceDetailsElement -->
           <!-- <gmp-place-details id="place-details-widget"></gmp-place-details> -->
       </div>
    </div>

    <!-- Floating Sidebar -->
    <aside id="sidebar" class="absolute top-3 left-3 w-80 max-w-[calc(100%-1.5rem)] bg-white rounded-lg shadow-lg z-10 flex flex-col overflow-hidden md:bottom-auto md:max-h-[calc(100%-2rem)] max-md:bottom-0 max-md:left-0 max-md:right-0 max-md:top-auto max-md:w-full max-md:max-w-full max-md:max-h-[40vh] max-md:rounded-none max-md:rounded-t-lg max-md:border-t">
        <!-- Header -->
        <div class="p-3 border-b flex-shrink-0"> <h2 class="text-lg font-semibold">Map App</h2> </div>
        <!-- Content -->
        <div class="sidebar-content flex-grow p-3 overflow-y-auto space-y-3">
            <!-- Autocomplete Input -->
            <div>
                <label for="autocomplete-input" class="block text-xs font-medium text-gray-600 mb-1">Search Location</label>
                <input id="autocomplete-input" type="text" placeholder="Enter address or place..." class="w-full text-sm form-input"/>
            </div>
            <!-- Example Button -->
            <button id="action-button" class="w-full px-3 py-1.5 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors">Do Action</button>
            <!-- Results/Details Area -->
            <div id="results-list" class="text-sm border-t mt-3 pt-3">
                <!-- Example List Item -->
                <!-- <div class="list-item" data-marker-id="item-1">Item 1</div> -->
            </div>
            <!-- Status Messages -->
            <div id="loading-indicator" class="mt-2 text-xs text-blue-600 italic hidden flex items-center gap-2">
                <svg class="animate-spin h-4 w-4 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"> <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle> <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path> </svg>
                <span id="loading-text">Loading...</span>
            </div>
            <div id="error-message" class="mt-2 text-xs text-red-600 font-medium"></div>
        </div>
    </aside>

    <!-- Main Application Script -->
    <script type="module">
      // --- Globals ---
      let map; // Holds 2D Map or 3D Map Element
      let autocomplete;
      let infoWindow; // For 2D map popups
      let activeMarkers = new Map(); // Use Map for state management
      let currentRoutePolyline = null; // Example state for route object

      const apiKey = "YOUR_API_KEY"; // *** REPLACE ***
      const mapId = "YOUR_MAP_ID";   // *** REPLACE for 2D Vector Maps ***

      // --- DOM Refs ---
      const mapDiv = document.getElementById('map');
      const mapContainer = document.getElementById('map-container');
      const loadingIndicator = document.getElementById('loading-indicator');
      const loadingText = document.getElementById('loading-text');
      const errorMessageDiv = document.getElementById('error-message');
      const acInput = document.getElementById('autocomplete-input');
      const actionButton = document.getElementById('action-button');
      const resultsList = document.getElementById('results-list');
      const detailsPanel = document.getElementById('details-panel');
      // Add other DOM refs as needed

      // --- Utility Functions (from Section 13) ---
      function showLoading(isLoading, text = "Loading...") {
          if (!loadingIndicator || !loadingText) return;
          loadingText.textContent = text;
          loadingIndicator.style.display = isLoading ? 'flex' : 'none';
          if (isLoading) showError(''); // Clear errors when loading starts
      }
      function showError(message) {
          if (!errorMessageDiv) return;
          errorMessageDiv.textContent = message || ''; // Clear if message is empty/null
          errorMessageDiv.style.display = message ? 'block' : 'none';
      }
      function showDetailsPanel(title = "Details", content = "...") {
          if (!detailsPanel) return;
          document.getElementById('details-title').textContent = title;
          document.getElementById('details-content').innerHTML = content; // Use innerHTML for flexibility
          detailsPanel.style.display = 'block';
      }
      function hideDetailsPanel() {
          if (detailsPanel) detailsPanel.style.display = 'none';
      }
      // --- Coordinate Conversion ---
      function apiToJsCoords(apiCoords) {
          if (!apiCoords) return null;
          return { lat: apiCoords.latitude, lng: apiCoords.longitude };
      }

      // --- Core Initialization ---
      async function init() {
        showLoading(true, "Initializing map...");
        showError(''); // Clear previous errors
        try {
          // *** CHOOSE ONE: init2DMap() or init3DMap() ***
          await init2DMap();
          // await init3DMap(); // Requires v=alpha in loader script

          await loadAndSetupServices(); // Load common JS services
          setupUIListeners(); // Setup Autocomplete, buttons, etc.

          console.log("Initialization complete.");
        } catch (error) {
          console.error("Initialization failed:", error);
          showError(`Map initialization failed: ${error.message}. Please check API key, Map ID, and enabled APIs.`);
        } finally {
          showLoading(false);
        }
      }

      async function init2DMap() {
        const { Map } = await google.maps.importLibrary("maps");
        const { InfoWindow } = await google.maps.importLibrary("maps"); // Load InfoWindow here

        if (!mapId) {
            throw new Error("Map ID is required for 2D Vector Maps and Advanced Markers.");
        }

        map = new Map(mapDiv, {
            center: { lat: 40.7128, lng: -74.0060 }, // New York City
            zoom: 12,
            mapId: mapId,
            gestureHandling: "cooperative",
            disableDefaultUI: true,
            zoomControl: true,
        });
        infoWindow = new InfoWindow(); // Initialize InfoWindow for 2D map

        // Example: Add listener to close InfoWindow on map click
        map.addListener('click', () => infoWindow.close());
        console.log("2D Map Initialized");
      }

      async function init3DMap() {
        // Ensure v=alpha in loader script in <head>
        const { Map3DElement, MapMode } = await google.maps.importLibrary("maps3d");
        map = new Map3DElement({
            center: { lat: 40.75, lng: -74.00, altitude: 150 }, // Near Times Square
            range: 1500, tilt: 60, heading: -30, mode: MapMode.HYBRID,
        });
        mapContainer.appendChild(map); // Append the element
        console.log("3D Map Initialized");
        // Add 3D map specific listeners if needed (e.g., gmp-click)
        // map.addEventListener('gmp-click', handle3DMapClick);
      }

      async function loadAndSetupServices() {
        showLoading(true, "Loading services...");
        // Load JS services like Autocomplete, PlacesService, Geocoder as needed
        const { Autocomplete } = await google.maps.importLibrary("places");
        // const { Geocoder } = await google.maps.importLibrary("geocoding");
        // const { ElevationService } = await google.maps.importLibrary("elevation");

        autocomplete = new Autocomplete(acInput, {
            fields: ["place_id", "geometry", "name", "formatted_address"], // *** MANDATORY fields ***
            types: ['establishment', 'geocode'] // Broad search
        });
        // Optional: Bias Autocomplete to map bounds
        // if (map instanceof google.maps.Map) { // Check if it's a 2D map
        //     autocomplete.bindTo("bounds", map);
        // }

        autocomplete.addListener('place_changed', handlePlaceSelection);

        // Initialize other services if needed
        // geocoder = new Geocoder();
        // elevator = new ElevationService();
        showLoading(false);
      }

      function setupUIListeners() {
        actionButton.addEventListener('click', handleActionButtonClick);
        // Add listeners for list items, etc.
        resultsList.addEventListener('click', handleResultItemClick);
      }

      // --- Event Handlers ---
      function handlePlaceSelection() {
          const place = autocomplete.getPlace(); // PlaceResult
          if (!place.place_id || !place.geometry?.location) {
              showError("Please select a valid place from the suggestions.");
              return;
          }
          showError(''); // Clear error
          console.log("Place selected:", place.name, place.place_id);

          // Example actions: Center map and add marker
          centerMapOnLocation(place.geometry.location);
          addOrUpdateMarker(place.geometry.location.toJSON(), place.name, place.place_id);

          // Optionally fetch more details using fetch or PlacesService
          // fetchPlaceDetailsFetch(place.place_id, apiKey).then(details => displayDetails(details));
      }

      function handleActionButtonClick() {
          showError(''); // Clear errors
          console.log("Action button clicked!");
          // Implement desired action, e.g., fetch route, search nearby, etc.
          showLoading(true, "Performing action...");
          // Simulate action
          setTimeout(() => {
              showLoading(false);
              console.log("Action complete.");
              // Update UI based on action result
          }, 1500);
      }

      function handleResultItemClick(event) {
          if (event.target.classList.contains('list-item') && event.target.dataset.markerId) {
              const markerId = event.target.dataset.markerId;
              const marker = activeMarkers.get(markerId);
              if (marker) {
                  // Highlight list item
                  document.querySelectorAll('.list-item.selected').forEach(el => el.classList.remove('selected'));
                  event.target.classList.add('selected');
                  // Center map on marker
                  centerMapOnLocation(marker.position);
                  // Show info (InfoWindow for 2D, Details Panel for 3D)
                  if (map instanceof google.maps.Map) {
                      infoWindow.setContent(`<strong>${marker.title}</strong>`);
                      infoWindow.open({ map: map, anchor: marker });
                  } else {
                      showDetailsPanel(marker.title, `Details for marker ${markerId}`);
                  }
              }
          }
      }

      // --- Map Interaction Functions ---
      function centerMapOnLocation(location, zoom = 15) {
          if (!map) return;
          if (map instanceof google.maps.Map) { // 2D Map
              map.setCenter(location);
              map.setZoom(zoom);
          } else if (map instanceof google.maps.maps3d.Map3DElement) { // 3D Map
              // Fly camera to the location (use helper if defined)
              const targetCoords = location instanceof google.maps.LatLng ? location.toJSON() : location;
              flyToLocation(map, { ...targetCoords, altitude: 50 }, 1000, 60, map.heading);
          }
      }

      // --- Marker Management (using state Map) ---
      async function addOrUpdateMarker(position, title, id) {
          if (!map || !position || !id) return;
          const markerId = id;

          // Remove existing marker with the same ID if it exists
          if (activeMarkers.has(markerId)) {
              const existingMarker = activeMarkers.get(markerId);
              if (map instanceof google.maps.Map) existingMarker.setMap(null);
              else if (map instanceof google.maps.maps3d.Map3DElement) map.removeChild(existingMarker);
              activeMarkers.delete(markerId);
          }

          let newMarker;
          if (map instanceof google.maps.Map) { // 2D Map
              const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");
              newMarker = new AdvancedMarkerElement({
                  position: position, map: map, title: title, gmpClickable: true,
              });
              newMarker.dataset.markerId = markerId; // Store ID for linking
              newMarker.addEventListener('gmp-click', () => {
                  infoWindow.setContent(`<strong>${title}</strong><br>ID: ${markerId}`);
                  infoWindow.open({ map: map, anchor: newMarker });
                  // Highlight corresponding list item
                  document.querySelectorAll('.list-item.selected').forEach(el => el.classList.remove('selected'));
                  document.querySelector(`.list-item[data-marker-id="${markerId}"]`)?.classList.add('selected');
              });
          } else { // 3D Map
              const { Marker3DInteractiveElement, AltitudeMode } = await google.maps.importLibrary("maps3d");
              const { PinElement } = await google.maps.importLibrary("marker");
              const elevation = await getClientElevation(position) ?? 10; // Fetch elevation
              newMarker = new Marker3DInteractiveElement({
                  position: { ...position, altitude: elevation + 10 },
                  altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
              });
              const pin = new PinElement({ background: '#1a73e8', glyphColor: '#fff' });
              newMarker.appendChild(pin);
              newMarker.dataset.markerId = markerId; // Store ID
              newMarker.addEventListener('gmp-click', (e) => {
                  console.log(`Clicked 3D marker: ${e.target.dataset.markerId} (${title})`);
                  showDetailsPanel(title, `Details for marker ${markerId}`);
                  // Highlight corresponding list item
                  document.querySelectorAll('.list-item.selected').forEach(el => el.classList.remove('selected'));
                  document.querySelector(`.list-item[data-marker-id="${markerId}"]`)?.classList.add('selected');
              });
              map.appendChild(newMarker);
          }
          activeMarkers.set(markerId, newMarker); // Store reference in state Map
          updateResultsList(); // Update sidebar list
      }

      function updateResultsList() {
          resultsList.innerHTML = ''; // Clear current list
          activeMarkers.forEach((marker, id) => {
              const div = document.createElement('div');
              div.className = 'list-item p-2 border-b cursor-pointer hover:bg-gray-100';
              div.textContent = marker.title || `Marker ${id}`;
              div.dataset.markerId = id; // Link list item to marker
              resultsList.appendChild(div);
          });
      }

      // --- Add Other App-Specific Functions ---
      // async function getClientElevation(latLng) { ... } // Defined in Section 9.3
      // async function fetchRoute(origin, destination, apiKey) { ... } // Defined in Section 10.2
      // async function displayRouteOnMap(...) { ... } // Defined in Section 10.2
      // async function flyToLocation(...) { ... } // Defined in Section 7.2

      // --- Start App ---
      init();

    </script>
</body>
</html>
```

## 15\. Summary & Key Takeaways for AI

* **Foundation:** GCP Project, Enabled APIs, Billing Account.  
* **Authentication:** API Keys MUST be restricted (HTTP Referrers \+ API Restrictions).  
* **Loading:** Use Inline Bootstrap Loader \+ `async/await google.maps.importLibrary()`. Use `v=beta` (2D/Standard) or `v=alpha` (3D/Experimental).  
* **API Prioritization:** Strongly prefer Places API (New) and Routes API via `fetch` over legacy or JS library alternatives (except for the standard Autocomplete widget). Use Address Validation API for deliverability.  
* **Cost Control:** MANDATORY use of `X-Goog-FieldMask` (for `fetch` APIs like Places New, Routes) or `fields` option (for JS Places library) is CRITICAL. Only request needed data.  
* **Map Choice:** `google.maps.Map` (2D, requires `mapId`) vs `Map3DElement` (3D, `v=alpha`, no `mapId`, uses altitude).  
* **Markers:** `AdvancedMarkerElement` (2D, requires `mapId`, use `content` or `appendChild` for customization, `gmpClickable`/`gmpDraggable`) vs `Marker3DElement`/`Marker3DInteractiveElement` (3D, `v=alpha`, requires position with altitude, `altitudeMode`, limited content via `appendChild`, `gmp-click` on interactive). Use `ElevationService` for accurate 3D placement.  
* **Coordinates:** CRITICAL: Handle conversions: `{lat, lng}` (JS API) vs `{latitude, longitude}` (`fetch` response) vs `[lng, lat]` (`deck.gl`). Altitude is crucial for 3D.  
* **Release Stages:** Prioritize GA. Use Preview/Experimental cautiously. AVOID Legacy.  
* **Error Handling:** Check `response.ok` for `fetch`. Examine `response.statusText` and potentially the JSON body of error responses for details. Use `try...catch` for async operations. Provide user feedback via `showError`.  
* **UI:** Link sidebar/map via IDs. Provide loading/error feedback. Use `deck.gl` for large-scale 2D viz. Manage map object references (e.g., in a `Map`) for updates/removal. Use `PlaceDetailsElement` for rich UI. Control 3D camera with `flyCameraTo`.