# gmp\_llms\_v2.txt

**1\. Goal & Scope**

* **Primary Goal:** Guide LLMs to generate modern, performant, secure, cost-effective Google Maps Platform (GMP) web applications.  
* **Target Stack:** Vanilla JS (ES2020+, async/await, modules), Tailwind CSS (CDN), HTML5. Assume single `index.html` unless specified.  
* **Focus:** Maps JavaScript API (Core, Places, Marker, etc.), prioritizing Places API (New) & Routes API via `fetch`, modern loading (`importLibrary`), API key security, cost control (Field Masks), release stage awareness, 2D Vector & 3D Photorealistic maps. **Strongly prefer Places UI Kit components (esp. `PlaceDetailsElement`) for displaying standard place details when using `v=alpha`.**  
* **AI Role:** Generate accurate, complete `index.html` files based *solely* on this context and user prompts. Enforce best practices rigorously. **Output MUST NOT contain any code comments.**  
* **Templates:** Provides two core templates: Section 14 (2D Map \+ Place Details UI Kit) and Section 14.1 (3D Map \+ Interactive Markers \+ Place Details UI Kit). Both require `v=alpha`.

**2\. API Selection Guide (Quick Reference)**

| Use Case | Recommended API / Method | Key Considerations |
| :---- | :---- | :---- |
| **Display Map** | **2D (Vector/Raster):** `google.maps.Map` (`maps` lib)  \*\*3D (Photorealistic):\*\* \`Map3DElement\` (\`maps3d\` lib) | 2D requires `mapId` & `v=alpha`. 3D requires `v=alpha`, no `mapId`, uses altitude. (See Sec 7\) |
| **Place Search (UI)** | `google.maps.places.Autocomplete` (`places` lib) | Standard UI widget. **MANDATORY `fields`** on `getPlace()` for cost. (See Sec 9.1) |
| **Place Search (Programmatic)** | **PREFER:** Places API (New) via `fetch` (Text Search, Nearby Search) | **MANDATORY `X-Goog-FieldMask`** header. Convert `{latitude, longitude}` to `{lat, lng}`. (See Sec 10.1) |
| **Place Details (UI)** | **PREFER (if `v=alpha`):** `PlaceDetailsElement` / `<gmp-place-details>` (`places` lib) | **Requires `v=alpha`**. Simpler & potentially cheaper for standard details vs. custom UI/InfoWindow. Embed in panel. (See Sec 9.1, 11\) |
| **Place Details (Programmatic)** | **PREFER:** Places API (New) via `fetch` (Place Details endpoint)  \*Alt (JS):\* \`PlacesService.getDetails\` / \`Place.fetchFields\` (\`places\` lib) | **MANDATORY `X-Goog-FieldMask`** (fetch) or `fields` (JS). Fetch preferred unless JS lib already needed. (See Sec 10.1, 9.1) |
| **Routing (All)** | **USE:** Routes API via `fetch` (computeRoutes, computeRouteMatrix) | **AVOID legacy Directions/Distance Matrix.** **MANDATORY `X-Goog-FieldMask`**. Decode polyline. Convert coords. (See Sec 10.2) |
| **Geocoding (Address \<-\> Coords)** | **User Input:** `google.maps.Geocoder` (`geocoding` lib)  \*\*Backend/Batch:\*\* Geocoding API via \`fetch\` | Use JS for real-time. Use fetch for known addresses/backend. (See Sec 9.2, 10.3) |
| **Address Validation** | Address Validation API via `fetch` | Specific use case for deliverability check, not general geocoding. (See Sec 10.4) |
| **Elevation Data** | **Client/Interactive:** `ElevationService` (`elevation` lib)  \*\*Backend/Batch:\*\* Elevation API via \`fetch\` | Essential for 3D placement (`AltitudeMode`). Use JS for interactive. (See Sec 9.3) |
| **Street View** | `StreetViewService`, `StreetViewPanorama` (`streetView` lib) | Client-side interactive panorama. (See Sec 9.4) |
| **Data Viz (Large)** | `deck.gl` \+ `GoogleMapsOverlay` (**2D Maps ONLY**) | High-performance WebGL layers. Use `[lng, lat]`. Load data directly or via `loaders.gl`. (See Sec 12\) |

**3\. Core Principles & Best Practices (MANDATORY)**

* **Security First:** API Keys MUST have **HTTP Referrer** restrictions (for client-side JS) AND **API Restrictions** (least privilege). Never expose unrestricted keys. Use separate keys per environment/app. (See Sec 5\)  
* **Modern Loading:** Use the **Inline Bootstrap Loader** \+ `async/await google.maps.importLibrary()`. AVOID legacy `libraries=` URL parameter. Use `v=alpha` (required for templates in Sec 14, 14.1). (See Sec 6\)  
* **Prioritize Modern APIs:** Strongly prefer **Places API (New)** and **Routes API** (via `fetch`) over legacy counterparts or JS library services where feasible (exception: Autocomplete widget). Use **Address Validation API** for deliverability. (See Sec 2, 9, 10\)  
* **Cost Control (CRITICAL):**  
  * **MANDATORY `X-Goog-FieldMask` header** for `fetch` APIs (Places New, Routes).  
  * **MANDATORY `fields` option** for JS Places library methods (`Autocomplete.getPlace()`, `PlacesService.getDetails()`, `Place.fetchFields()`).  
  * Only request needed data fields. Basic fields \= lower cost.  
* **Release Stage Awareness:** Prioritize GA. Use Preview/Experimental (`v=alpha`) cautiously (no SLAs, potential changes). AVOID Legacy APIs.  
* **Coordinate Systems:** Be precise. Convert as needed:  
  * JS API Elements (Markers, Polylines): `{ lat: number, lng: number }`  
  * `fetch` API Responses: Often `{ latitude: number, longitude: number }` \-\> **CONVERT**  
  * `deck.gl`: Typically `[longitude, latitude]` \-\> **CONVERT**  
  * Altitude required & significant for 3D. Use `ElevationService`.  
* **Attribution:** Ensure Google Maps attribution is displayed correctly.  
* **Generated Code Style:** Output clean, readable code. **ABSOLUTELY NO CODE COMMENTS (`//`, `/**/`) in the final generated `index.html` file.**

**4\. Setup: GCP Prerequisites**

* **Required Inputs (User Provided):** `YOUR_API_KEY`, `YOUR_MAP_ID` (for 2D Vector/Advanced Markers).  
* **Developer Actions:** Create/select GCP Project, Enable APIs (Maps JS, Places, Routes, Elevation, Geocoding, etc.), Link Cloud Billing.

**5\. API Key Management (Web \- CRITICAL)**

* **Generation:** GCP Console \> APIs & Services \> Credentials.  
* **Security Restrictions (MANDATORY):**  
  * **Application Restrictions:** Use **HTTP referrers** (e.g., `*.yourdomain.com/*`, `localhost/*`) for client-side keys.  
  * **API Restrictions:** Limit key to **ONLY** the specific GMP APIs needed.  
* **Best Practices:** Apply both restriction types tightly. Use separate keys (dev/prod). Never commit keys.

**6\. Maps JavaScript API Loading (Modern Standard)**

* **Inline Bootstrap Loader (Include ONCE in HTML `<head>`):**

```javascript
<script>
  (g=>{var h,a,k,p="The Google Maps JavaScript API",c="google",l="importLibrary",q="__ib__",m=document,b=window;b=b[c]||(b[c]={});var d=b.maps||(b.maps={}),r=new Set,e=new URLSearchParams,u=()=>h||(h=new Promise(async(f,n)=>{await(a=m.createElement("script"));e.set("libraries",[...r]+"");for(k in g)e.set(k.replace(/[A-Z]/g,t=>"_"+t.toLowerCase()),g[k]);e.set("callback",c+".maps."+q);a.src=`https://maps.${c}apis.com/maps/api/js?`+e;d[q]=f;a.onerror=()=>h=n(Error(p+" could not load."));a.nonce=m.querySelector("script[nonce]")?.nonce||"";m.head.append(a)}));d[l]?console.warn(p+" only loads once. Ignoring:",g):d[l]=(f,...n)=>r.add(f)&&u().then(()=>d[l](f,...n))})({
    key: "YOUR_API_KEY", // Replace with actual API key
    v: "alpha", // REQUIRED for 3D Maps and Places UI Kit (PlaceDetailsElement)
    // map_ids: "YOUR_MAP_ID", // Can specify here or in Map constructor (needed for 2D)
    // language: "en", region: "US" // Optional
  });
</script>
```

* **Dynamic Library Import (Inside `async` JS functions):**  
  * **IMPORTANT:** Call `google.maps.importLibrary()` **once** per library needed for the entire application, typically during initialization.  
  * Destructure the required classes/objects from the imported libraries.  
  * Store these destructured classes/objects in **module-level variables** so they are accessible throughout your script (in event handlers, helper functions, etc.).  
  * **DO NOT** call `google.maps.importLibrary()` again for the same library inside other functions. Use the module-level variables.

```javascript
// --- Module-level variables ---
let map, map3d, geocoder, autocomplete, elevator;
let Map, AdvancedMarkerElement, PinElement; // For 2D
let Map3DElement, Marker3DElement, Marker3DInteractiveElement, AltitudeMode, MapMode; // For 3D
let Autocomplete, Place, PlaceDetailsElement; // For Places
let LatLng, LatLngBounds; // For Core
let Geocoder; // For Geocoding
let ElevationService; // For Elevation
let encoding; // For Geometry

// --- Initialization Function (Example) ---
async function loadServicesAndComponents() {
  // Import all necessary libraries ONCE using Promise.all
  const [mapsLib, markerLib, placesLib, coreLib, geocodingLib, elevationLib, maps3dLib, geometryLib] = await Promise.all([
    google.maps.importLibrary("maps"),
    google.maps.importLibrary("marker"),
    google.maps.importLibrary("places"),
    google.maps.importLibrary("core"),
    google.maps.importLibrary("geocoding"),
    google.maps.importLibrary("elevation"),
    google.maps.importLibrary("maps3d"),
    google.maps.importLibrary("geometry")
  ]);

  // Assign destructured classes/objects to module-level variables
  // 2D Map related
  Map = mapsLib.Map;
  AdvancedMarkerElement = markerLib.AdvancedMarkerElement;
  PinElement = markerLib.PinElement; // Also used for 3D Markers

  // Places related
  Autocomplete = placesLib.Autocomplete;
  Place = placesLib.Place;
  PlaceDetailsElement = placesLib.PlaceDetailsElement;

  // Core related
  LatLng = coreLib.LatLng;
  LatLngBounds = coreLib.LatLngBounds;

  // Geocoding related
  Geocoder = geocodingLib.Geocoder;

  // Elevation related
  ElevationService = elevationLib.ElevationService;

  // 3D Map related (requires v=alpha)
  Map3DElement = maps3dLib.Map3DElement;
  Marker3DElement = maps3dLib.Marker3DElement;
  Marker3DInteractiveElement = maps3dLib.Marker3DInteractiveElement;
  AltitudeMode = maps3dLib.AltitudeMode;
  MapMode = maps3dLib.MapMode;

  // Geometry related
  encoding = geometryLib.encoding;

  // Initialize services as needed
  geocoder = new Geocoder();
  elevator = new ElevationService();
  // autocomplete = new Autocomplete(inputElement, options); // Initialize later when input exists
}

// --- Main Application Logic ---
async function init() {
  try {
    await loadServicesAndComponents(); // Load everything first
    // Now you can use the module-level variables like Map, PinElement, Marker3DInteractiveElement etc.
    // Example: Initialize the map (2D or 3D)
    // if (is3D) {
    //   map3d = new Map3DElement({ /* ... options ... */ });
    //   document.getElementById('map-container').appendChild(map3d);
    // } else {
    //   map = new Map(document.getElementById('map'), { /* ... options ... */ });
    // }
    // ... setup autocomplete, event listeners, initial data load ...
  } catch (error) {
    console.error("Initialization failed:", error);
    // Show error to user
  }
}

// --- Example Usage in another function ---
function add3DMarker(position, title) {
  // Use the module-level variables directly
  if (!map3d || !Marker3DInteractiveElement || !PinElement || !AltitudeMode) {
    console.error("3D Map or required components not initialized.");
    return;
  }
  const pin = new PinElement({ background: '#DB4437', glyphColor: '#fff' });
  const marker = new Marker3DInteractiveElement({
    position: position, // { lat, lng, altitude }
    altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
    title: title
  });
  marker.appendChild(pin); // Correct way to add PinElement
  map3d.appendChild(marker);
  // ... add event listeners etc. ...
}

// Start the application
// init();
```

**7\. Core Maps JavaScript API Components**

* **7.1. 2D Map (`google.maps.Map`)**  
  * Requires `v=alpha` (for consistency with templates), `maps` library.  
  * **`mapId: "YOUR_MAP_ID"` is REQUIRED** for Vector maps & Advanced Markers.

```javascript
// Assumes 'Map' is loaded and assigned to a module-level variable
const map = new Map(document.getElementById('map'), {
  center: { lat: -34.397, lng: 150.644 }, zoom: 8,
  mapId: "YOUR_MAP_ID", // REQUIRED
  gestureHandling: "greedy", disableDefaultUI: true, zoomControl: true,
});
```

* **7.2. 3D Map (`Map3DElement`)**  
  * Requires `v=alpha`, `maps3d` library. Web Component. **NO `mapId`**.  
  * Requires `center` with `altitude`.

```javascript
// Assumes 'Map3DElement', 'MapMode' are loaded and assigned to module-level variables
const mapContainer = document.getElementById('map-container'); // Container div
const map3d = new Map3DElement({
    center: { lat: 40.75, lng: -74.00, altitude: 100 }, // *** Altitude REQUIRED ***
    range: 1000, // Distance from camera to center in meters
    tilt: 65,    // Camera angle (0=straight down, 90=horizon)
    heading: -45, // Compass direction (0=North)
    mode: MapMode.HYBRID, // Or MapMode.SATELLITE
    defaultUIDisabled: true, // to disable controls, recommended
    // Optional restrictions:
    // minAltitude: 50, maxAltitude: 10000,
    // minTilt: 0, maxTilt: 75,

});
mapContainer.innerHTML = ''; // Clear container
mapContainer.appendChild(map3d); // Add to DOM
```

* **3D Camera Control:** Use `map3d.flyCameraTo({ endCamera: {...}, durationMillis: N })`, `map3d.flyCameraAround({ camera: {...}, durationMillis: N, rounds: N })`, `map3d.stopCameraAnimation()`.

```javascript
// Example: Fly camera to a new location
async function flyToLocation(map3dInstance, targetCoords, range, tilt, heading, duration = 1500) {
    if (!map3dInstance) return;
    const endCamera = { center: targetCoords, range, tilt, heading };
    try {
        await map3dInstance.flyCameraTo({ endCamera, durationMillis: duration });
        console.log("Fly-to animation complete.");
    } catch (error) {
        if (error.name === 'AbortError' || error.message?.includes('interrupted')) {
           console.log("Camera animation interrupted.");
        } else { console.error("flyCameraTo error:", error); }
    }
}
// Usage:
// const target = { lat: 35.6586, lng: 139.7454, altitude: 500 }; // Tokyo Tower area
// flyToLocation(map3d, target, 1000, 60, 0);
```

* **3D Events:** Use `element.addEventListener('gmp-click', handler)`, `element.addEventListener('gmp-steadychange', handler)`, etc. Distinguish `LocationClickEvent` (click on map terrain/water) vs `PlaceClickEvent` (click on POI).

```javascript
// Example: Handle clicks on the 3D map
map3d.addEventListener('gmp-click', (event) => {
    if (event.detail?.placeId) { // PlaceClickEvent (POI clicked)
        console.log('Clicked Place ID:', event.detail.placeId);
        // Optionally fetch place details: event.fetchPlace().then(place => ...);
        // Optionally show PlaceDetailsElement: showPlaceDetails(event.detail.placeId);
    } else if (event.detail?.position) { // LocationClickEvent (Map clicked)
        console.log('Clicked Map Location:', event.detail.position); // {lat, lng, altitude}
    }
});
```

**8\. Key JS API Features & Elements**

* **8.1. Markers**  
  * **2D (`AdvancedMarkerElement`):** Requires `marker` lib, `mapId` on Map. Position `{lat, lng}`. Use `content` (PinElement/HTML) or default pin. Use `gmpClickable: true` \+ `addEventListener('gmp-click', ...)` or `addListener('click', ...)`. `collisionBehavior`.

```javascript
// Assumes 'AdvancedMarkerElement' is loaded and assigned
// Basic
const marker2d = new AdvancedMarkerElement({ map, position: { lat: -34.397, lng: 150.644 }, title: "..." });
// Custom HTML Content
const contentEl = document.createElement('div'); contentEl.textContent = '$10';
const htmlMarker = new AdvancedMarkerElement({ map, position: {...}, content: contentEl });
```

* **3D (`Marker3DElement`/`Marker3DInteractiveElement`):** Requires `v=alpha`, `maps3d` lib. Position `{lat, lng, altitude}` (REQUIRED). Use `AltitudeMode` (e.g., `RELATIVE_TO_GROUND`, `ABSOLUTE`). Content: Default pin, `PinElement`, or `<template>` with `<img>`/`<svg>`. Use `Marker3DInteractiveElement` \+ `addEventListener('gmp-click', ...)` for clicks.  
  * **Using `PinElement`:** Create a `PinElement` instance and append it directly to the `Marker3DElement` or `Marker3DInteractiveElement` using `marker.appendChild(pin)`. **Do not** append `pin.element`.

```javascript
// Assumes 'Marker3DInteractiveElement', 'PinElement', 'AltitudeMode' are loaded and assigned
// Assumes 'map3d' is the initialized 3D map instance
// Assumes 'getClientElevation' function exists (See Sec 9.3)

const elevation = await getClientElevation({ lat: 40.75, lng: -74.00 });
const positionWithAltitude = { lat: 40.75, lng: -74.00, altitude: (elevation ?? 10) + 15 }; // Example: 15m above ground

// Create the interactive marker
const marker3d = new Marker3DInteractiveElement({
    position: positionWithAltitude,
    altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
    title: "My 3D Marker"
});

// Create the PinElement for content
const pin = new PinElement({
    background: "#FBBC04", // Example color
    glyphColor: "#000",
    scale: 1.2
});

// *** CORRECT USAGE: Append the PinElement instance directly ***
marker3d.appendChild(pin);

// Add click listener
marker3d.addEventListener('gmp-click', (e) => {
    console.log('Clicked 3D Marker:', e.target.title);
    // Handle click, e.g., show details panel
});

// Add the marker (with pin inside) to the map
map3d.appendChild(marker3d);
```

* **8.2. Drawing (Lines/Areas)**  
  * **2D (`Polyline`, `Polygon`):** `maps` lib. Path: `[{ lat, lng }, ...]`. Options: `strokeColor`, `strokeWeight`, `geodesic: true`.  
  * **3D (`Polyline3DElement`, `Polygon3DElement`):** `v=alpha`, `maps3d` lib. Coordinates: `[{ lat, lng, altitude }, ...]`. Use `AltitudeMode`. Options: `strokeColor`, `strokeWidth`, `extruded: true`.  
* **8.3. Info Windows (2D Maps Only)**  
  * `maps` lib. Popup anchored to `AdvancedMarkerElement`.  
  * **Note:** Use only for *custom* HTML content not suitable for `PlaceDetailsElement`. **The primary templates (Sec 14, 14.1) use `PlaceDetailsElement` instead.** If using InfoWindow, style via CSS (see Sec 14 template CSS for examples like `.gm-style-iw-c`).

**9\. Essential JS API Services (Client-Side)**

* **9.1. Places Library (`places` lib)**  
  * **Autocomplete Widget:** Standard UI. **MANDATORY `fields`** option on `getPlace()`. Listen for `place_changed`.

```javascript
// Assumes 'Autocomplete' is loaded and assigned, 'map' is initialized 2D map
const acInput = document.getElementById('autocomplete-input');
const autocomplete = new Autocomplete(acInput, {
    fields: ["place_id", "geometry", "name", "formatted_address"], // MANDATORY fields
    types: ['geocode', 'establishment']
});
// Optional: autocomplete.bindTo("bounds", map); // Bias results to map viewport
autocomplete.addListener('place_changed', () => {
    const place = autocomplete.getPlace();
    if (!place.geometry?.location) { console.log("Invalid place selected"); return; }
    // Use place.geometry.location, place.place_id, place.name etc.
});
```

```
*   **Place Details Element (JS Class/Web Component):** Requires `v=alpha`. **PREFERRED** for standard details display. Embed in panel. Configure via `configureFromPlace({id})` or `configureFromLocation(latLng)`. **Used in both core templates (Sec 14, 14.1).**
```

```javascript
// JS Class (v=alpha) - Used in templates
// Assumes 'PlaceDetailsElement' is loaded and assigned
const panelContainer = document.getElementById('details-panel-content'); // Container for the element
const detailsEl = new PlaceDetailsElement(); // Create instance
panelContainer.appendChild(detailsEl); // Add to DOM container
// ... later, when needed:
async function showDetails(placeId) {
    try {
        await detailsEl.configureFromPlace({ id: placeId });
        document.getElementById('details-panel').style.display = 'flex'; // Show the panel
    } catch (error) {
        console.error("Error configuring Place Details:", error);
        // Handle error
    }
}
```

* *Other:* `PlacesService.getDetails` / `Place.fetchFields` (use `fields`, generally prefer `fetch` API or `PlaceDetailsElement`).

* **9.2. Geocoding (`geocoding` lib)**  
  * Client-side address \<-\> coords. Prefer `fetch` API for backend.

```javascript
// Assumes 'geocoder' is initialized (new Geocoder())
async function geocodeAddress(address) {
    try {
        const { results } = await geocoder.geocode({ address: address });
        if (results?.[0]?.geometry?.location) {
            return results[0]; // Contains geometry.location, place_id, formatted_address etc.
        } else {
            console.warn("Geocoding: No results found for", address);
            return null;
        }
    } catch (error) {
        console.error("Geocoding failed:", error);
        return null;
    }
}
```

* **9.3. Elevation (`elevation` lib)**  
  * Client-side elevation lookup. Essential for 3D `AltitudeMode`.

```javascript
// Assumes 'elevator' is initialized (new ElevationService())
// Single point
async function getClientElevation(latLng) { // latLng = { lat: number, lng: number }
    if (!elevator) return null;
    try {
        const { results } = await elevator.getElevationForLocations({ locations: [latLng] });
        if (results?.[0]?.elevation != null) {
            return results[0].elevation; // Returns elevation number
        } else {
            console.warn("Elevation: No result for", latLng);
            return null;
        }
    } catch (e) {
        console.error("Elevation lookup failed:", e);
        return null;
    }
}
// Batch points (more efficient for multiple lookups)
async function getElevationsForPoints(locations) { // locations = [{ lat, lng }, ...]
    if (!elevator || locations.length === 0) return locations.map(() => null);
    const batchSize = 200; // API limit often around 512, use smaller batches
    let allElevations = [];
    for (let i = 0; i < locations.length; i += batchSize) {
        const batchLocations = locations.slice(i, i + batchSize);
        try {
            const { results } = await elevator.getElevationForLocations({ locations: batchLocations });
            const elevations = results.map(result => result?.elevation ?? null);
            allElevations.push(...elevations);
        } catch (e) {
            console.error(`Elevation fetch error for batch starting at index ${i}:`, e);
            allElevations.push(...Array(batchLocations.length).fill(null)); // Fill failed batch with null
        }
    }
    return allElevations; // Returns array of elevations or nulls
}
```

* **9.4. Street View (`streetView` lib)**  
  * Display panorama in a `<div>`.

```javascript
// Assumes 'StreetViewService', 'StreetViewPanorama' are loaded
const svService = new google.maps.StreetViewService();
const panoramaDiv = document.getElementById('panorama-div');
const panorama = new google.maps.StreetViewPanorama(panoramaDiv);
const location = { lat: 40.75, lng: -74.00 }; // Example location

svService.getPanorama({ location: location, radius: 50 }, (data, status) => {
  if (status === google.maps.StreetViewStatus.OK && data?.location?.pano) {
    panorama.setPano(data.location.pano);
    panorama.setVisible(true);
  } else {
    console.error('Street View data not found for this location.');
    panorama.setVisible(false);
  }
});
```

**10\. Key Web Service APIs (`fetch`)**

* **General:** Prefer backend proxy. If client-side `fetch`, use **MANDATORY strict HTTP Referrers**. Handle errors (`response.ok`). Use **MANDATORY `X-Goog-Api-Key` header**.  
* **10.1. Places API (New):** PREFER for programmatic search/details. **MANDATORY `X-Goog-FieldMask` header**. Convert `{latitude, longitude}` response coords.

```javascript
// Example: Text Search
async function searchPlaces(query, apiKey) {
    const response = await fetch('https://places.googleapis.com/v1/places:searchText', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Goog-Api-Key': apiKey,
        'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.location,places.rating,places.userRatingCount' // Adjust fields as needed
      },
      body: JSON.stringify({
        textQuery: query,
        maxResultCount: 10 // Example limit
        // locationBias: { circle: { center: { latitude: ..., longitude: ... }, radius: ... } } // Optional bias
      })
    });
    if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Places API Error (${response.status}): ${errorData.error?.message || response.statusText}`);
    }
    const data = await response.json();
    return data.places || []; // Returns array of place objects
}
// Other endpoints: :searchNearby, /v1/places/{PLACE_ID}
```

* **10.2. Routes API:** USE for all routing. **MANDATORY `X-Goog-FieldMask` header**. Decode `routes.polyline.encodedPolyline` (use `geometry` lib). Convert waypoint/leg coords.

```javascript
// Example: Compute Routes
async function getRoute(origin, destination, apiKey) {
    const response = await fetch('https://routes.googleapis.com/directions/v2:computeRoutes', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Goog-Api-Key': apiKey,
        'X-Goog-FieldMask': 'routes.duration,routes.distanceMeters,routes.polyline.encodedPolyline,routes.legs.startLocation,routes.legs.endLocation' // Adjust fields
       },
      body: JSON.stringify({
        origin: { address: origin }, // Can also use { placeId: '...' } or { location: { latLng: { latitude: ..., longitude: ... } } }
        destination: { address: destination },
        travelMode: 'DRIVE', // Or 'WALK', 'BICYCLE', 'TRANSIT'
        // computeAlternativeRoutes: false, // Optional
        // routeModifiers: { avoidTolls: false }, // Optional
      })
    });
    if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Routes API Error (${response.status}): ${errorData.error?.message || response.statusText}`);
    }
    const data = await response.json();
    return data.routes?.[0]; // Returns the first route object or undefined
}

// Helper: Decode Polyline (Requires 'encoding' from geometry lib)
function decodePolyline(encodedPolyline) {
    if (!encodedPolyline || !encoding) return [];
    return encoding.decodePath(encodedPolyline).map(p => ({ lat: p.lat(), lng: p.lng() }));
    // Returns array of { lat, lng }
}

// Helper: Display Route on 2D Map (Requires geometry, maps, marker, core libs)
async function displayRouteOn2DMap(route, mapInstance) {
    if (!route?.polyline?.encodedPolyline || !mapInstance) return;
    // Assumes Polyline, AdvancedMarkerElement, LatLngBounds are loaded
    const decodedPath = decodePolyline(route.polyline.encodedPolyline);
    if (decodedPath.length === 0) return;

    const routePolyline = new google.maps.Polyline({
        path: decodedPath,
        strokeColor: '#1A73E8', strokeWeight: 5, strokeOpacity: 0.8,
        map: mapInstance
    });

    // Add start/end markers (optional)
    const startLatLng = decodedPath[0];
    const endLatLng = decodedPath[decodedPath.length - 1];
    new AdvancedMarkerElement({ position: startLatLng, map: mapInstance, title: 'Start' });
    new AdvancedMarkerElement({ position: endLatLng, map: mapInstance, title: 'End' });

    // Fit map bounds to the route
    const bounds = new LatLngBounds();
    decodedPath.forEach(point => bounds.extend(point));
    mapInstance.fitBounds(bounds, 100); // 100px padding

    return routePolyline; // Return the polyline object if needed
}

// Helper: Display Route on 3D Map (Requires geometry, maps3d, core libs + ElevationService)
async function displayRouteOn3DMap(route, map3dInstance) {
    if (!route?.polyline?.encodedPolyline || !map3dInstance) return;
    // Assumes Polyline3DElement, AltitudeMode are loaded, getElevationsForPoints exists
    const decodedPathLatLng = decodePolyline(route.polyline.encodedPolyline);
    if (decodedPathLatLng.length === 0) return;

    // Get elevations for the path points
    const elevations = await getElevationsForPoints(decodedPathLatLng);
    const pathWithAltitude = decodedPathLatLng.map((point, index) => ({
        ...point,
        altitude: (elevations[index] ?? 10) + 5 // Example: 5m above ground
    }));

    const routePolyline3D = new google.maps.Polyline3DElement({
        coordinates: pathWithAltitude,
        altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
        strokeColor: '#1A73E8', strokeWidth: 8,
        // extruded: false, // Optional
    });
    map3dInstance.appendChild(routePolyline3D);

    // Fly camera to view the route (optional)
    if (pathWithAltitude.length > 0) {
        const midIndex = Math.floor(pathWithAltitude.length / 2);
        const centerPoint = pathWithAltitude[midIndex];
        const range = route.distanceMeters ? route.distanceMeters * 1.5 : 5000; // Estimate range
        flyToLocation(map3dInstance, centerPoint, range, 45, 0);
    }

    return routePolyline3D; // Return the 3D polyline object if needed
}
```

* **10.3. Geocoding API:** Backend/batch use.

```javascript
async function geocodeServerSide(address, apiKey) {
    const encodedAddress = encodeURIComponent(address);
    const response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?address=${encodedAddress}&key=${apiKey}`);
    if (!response.ok) {
        throw new Error(`Geocoding API Error (${response.status}): ${response.statusText}`);
    }
    const data = await response.json();
    if (data.status !== 'OK') {
        throw new Error(`Geocoding API Error: ${data.status} - ${data.error_message || ''}`);
    }
    return data.results; // Returns array of geocoding results
}
```

* **10.4. Address Validation API:** Deliverability checks.

```javascript
async function validateAddress(addressObject, apiKey) {
    // addressObject example: { regionCode: 'US', addressLines: ['1600 Amphitheatre Pkwy', 'Mountain View', 'CA 94043'] }
    const response = await fetch(`https://addressvalidation.googleapis.com/v1:validateAddress?key=${apiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ address: addressObject })
    });
    if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Address Validation API Error (${response.status}): ${errorData.error?.message || response.statusText}`);
    }
    const data = await response.json();
    return data.result; // Contains validation verdict, address components, geocode, etc.
}
```

**11\. Experimental / Preview Features (Use with Caution)**

* Requires `v=alpha`. APIs/behavior may change.  
* **Places UI Kit Components (`v=alpha`, `places` lib):**  
  * `PlaceDetailsElement` / `<gmp-place-details>`: **PREFER** for standard details UI. (See Sec 9.1 for JS Class, example below for Web Component).

```html
<!-- Web Component HTML -->
<div id="details-panel" style="display: none;">
    <!-- Header/Close button can be added here -->
    <gmp-place-details id="place-details-widget" size="medium"></gmp-place-details>
</div>
```

```javascript
// Web Component JS Configuration
async function showDetailsWebComponent(placeId) {
    const widget = document.getElementById('place-details-widget');
    const panel = document.getElementById('details-panel');
    if (!widget || !panel) return;
    try {
        // Ensure the component is defined (might need a small delay or check)
        await customElements.whenDefined('gmp-place-details');
        await widget.configureFromPlace({ id: placeId });
        panel.style.display = 'block'; // Or 'flex' etc.
    } catch (error) {
        console.error("Error configuring Place Details WC:", error);
        // Handle error
    }
}
```

```
*   Others: `<gmp-place-picker>`, `<gmp-place-overview>`, etc.
```

* **Air Quality Meter (`v=alpha`, `airquality` lib):** `<gmp-air-quality-meter>`  
* **Web Components (`v=beta`/GA):** `<gmp-map>`, `<gmp-advanced-marker>`

## 12\. Data Loading & Visualization (Optional Libraries)

Use these for handling larger datasets or creating advanced visualizations, primarily on 2D maps.

### 12.1. Data Loading Strategy

* **Simple Formats (GeoJSON, JSON arrays):** `deck.gl` layers often handle direct loading via the `data` prop (e.g., passing a URL to `GeoJsonLayer`, or a fetched JSON array to `ScatterplotLayer`). Prefer this direct approach when possible.  
* **Complex Formats / Pre-processing (CSV, KML, binary, large files):** Use `loaders.gl` for robust parsing and handling before passing the processed data array to `deck.gl` layers.

### 12.2. `deck.gl` (High-Performance Visualization \- 2D Maps Only)

* **Purpose:** WebGL-powered visualization layers for large datasets (points, lines, polygons, heatmaps, hexbins, etc.). Integrates with Google Maps 2D ONLY via `GoogleMapsOverlay`.  
* **CDN:** `<script src="https://unpkg.com/deck.gl@latest/dist.min.js"></script>`, `<script src="https://unpkg.com/@deck.gl/google-maps@latest/dist.min.js"></script>`. (May need additional layer modules like `@deck.gl/layers`, `@deck.gl/aggregation-layers`, etc. depending on usage).  
* **Usage:**  
  1. Initialize the overlay: `const deckOverlay = new deck.GoogleMapsOverlay({ layers: [] });`  
  2. Link to the `google.maps.Map` instance: `deckOverlay.setMap(map);` (where `map` is your 2D map).  
  3. Update layers dynamically: `deckOverlay.setProps({ layers: [ newLayer1, newLayer2, ... ] });`  
* **Coordinate Format:** Most layers expect `getPosition`, `getPath`, `getPolygon` etc. accessors to return coordinates in **`[longitude, latitude]`** order. **CRITICAL:** Convert data if necessary.  
* **Interaction:** Enable via `pickable: true`. Use `onHover`, `onClick`, `autoHighlight: true`, and `getTooltip: ({object}) => ...` for user feedback.  
* **Performance:** Use `updateTriggers` prop to fine-tune when accessors are recalculated. Consider `Fp64Extension` for high-precision coordinate systems if needed (requires `extensions` prop).  
* **Dynamic Properties:** Use functions for accessors (`getRadius`, `getFillColor`) to style features based on their properties (e.g., earthquake magnitude). Update the `updateTriggers` prop when the property being visualized changes.

**Common Layer Categories & Examples:** (Refer to `gmp_llms_v2.txt` for detailed list)

**Example: Scatterplot Layer Integration (Minimal)**

```javascript
// Assumes deck.gl core, layers, and google-maps overlay are loaded globally
// Assumes 'map' is 2D google.maps.Map instance
// Assumes 'myData' is array of { longitude: number, latitude: number, magnitude: number }
// Assumes 'tooltipDiv' exists in HTML for hover info

let deckOverlay; // Store overlay instance

function initializeDeckGlOverlay(mapInstance) {
    if (!window.deck || !window.deck.GoogleMapsOverlay) {
      console.warn("deck.gl libraries not loaded."); return;
    }
    deckOverlay = new deck.GoogleMapsOverlay({ layers: [] });
    deckOverlay.setMap(mapInstance);
}

function updateDeckLayers(data) {
  if (!deckOverlay || !data) return;

  const scatterLayer = new deck.ScatterplotLayer({
    id: 'data-scatter',
    data: data,
    // *** COORDINATE ORDER: [longitude, latitude] ***
    getPosition: d => [d.longitude, d.latitude],
    // Style based on data properties (example: magnitude)
    getRadius: d => Math.max(1, d.magnitude) * 10, // Radius based on magnitude
    getFillColor: d => d.magnitude > 5 ? [255, 0, 0, 180] : [255, 140, 0, 150], // Red/Orange
    radiusUnits: 'meters',
    radiusMinPixels: 1, radiusMaxPixels: 40,
    // Interaction
    pickable: true, autoHighlight: true,
    onHover: handleDeckHover, // Tooltip function
    onClick: (info) => { // Example click handler
        if (info.object) console.log('Clicked:', info.object);
    }
  });

  deckOverlay.setProps({ layers: [scatterLayer] });
}

// --- Tooltip Handling ---
function handleDeckHover({object, x, y}) {
    const tooltipDiv = document.getElementById('tooltip'); // Get tooltip div
    if (!tooltipDiv) return;
    if (object) {
        tooltipDiv.style.left = `${x}px`; tooltipDiv.style.top = `${y}px`;
        tooltipDiv.innerHTML = `
            <strong>Magnitude:</strong> ${object.magnitude?.toFixed(1) ?? 'N/A'}<br>
            <strong>Location:</strong> ${object.latitude?.toFixed(3)}, ${object.longitude?.toFixed(3)}
        `;
        tooltipDiv.style.display = 'block';
    } else {
        tooltipDiv.style.display = 'none';
    }
}

// --- Initialization & Data Loading ---
// async function start() {
//   await init2DMap(); // Assuming this initializes the 'map' variable
//   initializeDeckGlOverlay(map);
//   const data = await loadData(); // Your data loading function
//   if(data) updateDeckLayers(data);
// }
// start();
```

**13\. UI & Interaction Patterns**

* **Linking List \<-\> Map:** Use unique IDs (`data-place-id` or `data-location-id`). Store markers in a `Map` state object (`activeMarkers = new Map()`). On list click, find marker via ID, trigger marker click (`google.maps.event.trigger(marker, 'gmp-click')` for 2D) or fly camera (3D). On marker click, find list item via ID (`querySelector`), highlight it (`.selected` class), scroll into view. (See Sec 14, 14.1 templates).  
* **Loading/Error Feedback:** Use simple divs (`#loading-indicator`, `#error-message`) toggled via JS utility functions (`showLoading`, `showError`). Provide clear messages.  
* **Info Panel Toggle:** Use a container div (`#details-panel`) for `PlaceDetailsElement`. Toggle visibility (`display: flex/none`).  
* **State Management:** Use module-level variables for simple state (`map`, `apiKey`, imported classes). Use a `Map` object (`activeMarkers = new Map()`) for managing collections of map objects (markers, lines) by ID for easy access/update/removal.

**14\. HTML/CSS/JS Template (2D Map \+ Place Details UI Kit)**

* **Note:** This template uses `v=alpha`. It shows nearby places and uses the UI Kit component in a panel for details.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nearby Places (2D)</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
    <style>
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; }
        #map-container { height: 100%; width: 100%; position: relative; }
        #map { height: 100%; width: 100%; background-color: #e5e7eb; }
        .sidebar-content::-webkit-scrollbar { width: 6px; }
        .sidebar-content::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 3px; }
        .pac-container { z-index: 1051 !important; }
        #details-panel { position: absolute; top: 1rem; right: 1rem; background: white; border-radius: 0.5rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 20; max-width: 350px; max-height: calc(100vh - 2rem); display: none; flex-direction: column; }
        #details-panel .panel-header { padding: 0.5rem 0.75rem; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center; }
        #details-panel .panel-header h3 { font-size: 0.9rem; font-weight: 600; margin: 0; }
        #details-panel .close-button { background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0.25rem; line-height: 1; }
        #details-panel .panel-content { padding: 0; overflow-y: auto; flex-grow: 1; }
        gmp-place-details { display: block; width: 100%; }
        .list-item { display: flex; align-items: center; padding: 12px 16px; border-bottom: 1px solid #e0e0e0; cursor: pointer; transition: background-color 0.15s ease-in-out; }
        .list-item:hover { background-color: #f5f5f5; }
        .list-item.selected { background-color: #e8f0fe; border-left: 4px solid #1967d2; padding-left: 12px; }
        .list-item .rank { font-size: 0.9rem; font-weight: 500; color: #1967d2; width: 24px; text-align: center; margin-right: 16px; }
        .list-item .content { flex: 1; }
        .list-item .name { font-size: 0.95rem; font-weight: 500; color: #202124; margin-bottom: 2px; }
        .list-item .details { font-size: 0.8rem; color: #5f6368; display: flex; align-items: center; gap: 4px; margin-bottom: 4px; }
        .list-item .details svg { width: 14px; height: 14px; fill: #fbbc04; }
        .list-item .address { font-size: 0.8rem; color: #5f6368; }
        .shop-marker-tag { background-color: #1A73E8; color: white; padding: 5px 10px; border-radius: 4px; font-size: 0.8rem; font-weight: 500; box-shadow: 0 1px 3px rgba(0,0,0,0.2); white-space: nowrap; }
    </style>
    <script>
      (g=>{var h,a,k,p="The Google Maps JavaScript API",c="google",l="importLibrary",q="__ib__",m=document,b=window;b=b[c]||(b[c]={});var d=b.maps||(b.maps={}),r=new Set,e=new URLSearchParams,u=()=>h||(h=new Promise(async(f,n)=>{await(a=m.createElement("script"));e.set("libraries",[...r]+"");for(k in g)e.set(k.replace(/[A-Z]/g,t=>"_"+t.toLowerCase()),g[k]);e.set("callback",c+".maps."+q);a.src=`https://maps.${c}apis.com/maps/api/js?`+e;d[q]=f;a.onerror=()=>h=n(Error(p+" could not load."));a.nonce=m.querySelector("script[nonce]")?.nonce||"";m.head.append(a)}));d[l]?console.warn(p+" only loads once. Ignoring:",g):d[l]=(f,...n)=>r.add(f)&&u().then(()=>d[l](f,...n))})({
        key: "YOUR_API_KEY", v: "alpha", map_ids: "YOUR_MAP_ID"
      });
    </script>
</head>
<body class="relative h-screen overflow-hidden antialiased text-gray-800">
    <div id="map-container" class="absolute inset-0 z-0">
       <div id="map"></div>
    </div>
    <aside id="sidebar" class="absolute top-3 left-3 w-80 max-w-[calc(100%-1.5rem)] bg-white rounded-lg shadow-lg z-10 flex flex-col overflow-hidden md:bottom-auto md:max-h-[calc(100%-2rem)] max-md:bottom-0 max-md:left-0 max-md:right-0 max-md:top-auto max-md:w-full max-md:max-w-full max-md:max-h-[40vh] max-md:rounded-none max-md:rounded-t-lg max-md:border-t">
        <div class="p-3 border-b flex-shrink-0">
            <h2 id="sidebar-title" class="text-lg font-semibold">Nearby Places</h2>
            <p id="sidebar-subtitle" class="text-xs text-gray-500">Search for a location</p>
        </div>
        <div class="sidebar-content flex-grow p-3 overflow-y-auto space-y-3">
            <div>
                <label for="autocomplete-input" class="block text-xs font-medium text-gray-600 mb-1">Search Location</label>
                <input id="autocomplete-input" type="text" placeholder="Enter address or place..." class="w-full text-sm form-input"/>
            </div>
            <div id="loading-indicator" class="mt-2 text-xs text-blue-600 italic hidden flex items-center gap-2">
                <svg class="animate-spin h-4 w-4 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"> <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle> <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path> </svg>
                <span id="loading-text">Loading...</span>
            </div>
            <div id="error-message" class="mt-2 text-xs text-red-600 font-medium"></div>
             <div id="results-list" class="text-sm border-t mt-3 pt-3"></div>
        </div>
    </aside>
    <div id="details-panel">
        <div class="panel-header">
            <h3>Place Details</h3>
            <button class="close-button" onclick="hidePlaceDetailsPanel()">Ã—</button>
        </div>
        <div class="panel-content">
            <gmp-place-details size="medium" id="place-details-widget"></gmp-place-details>
        </div>
    </div>
    <script type="module">
      let map, geocoder, autocomplete, searchOriginMarker;
      let Map, AdvancedMarkerElement, PinElement, Autocomplete, PlaceDetailsElement, Geocoder, LatLngBounds; // Module-level variables for classes
      let activeMarkers = new Map();
      let searchOrigin = null;
      let placeDetailsWidget;
      const apiKey = "YOUR_API_KEY";
      const mapId = "YOUR_MAP_ID";
      const defaultSearchAddress = "Moscone Center, San Francisco, CA";
      const searchRadiusMeters = 1500;
      const placeTypeQuery = "coffee shop";

      const mapDiv = document.getElementById('map');
      const acInput = document.getElementById('autocomplete-input');
      const sidebarTitle = document.getElementById('sidebar-title');
      const sidebarSubtitle = document.getElementById('sidebar-subtitle');
      const loadingIndicator = document.getElementById('loading-indicator');
      const loadingText = document.getElementById('loading-text');
      const errorMessageDiv = document.getElementById('error-message');
      const resultsListDiv = document.getElementById('results-list');
      const detailsPanel = document.getElementById('details-panel');

      function showLoading(isLoading, text = "Loading...") {
          if (!loadingIndicator || !loadingText) return;
          loadingText.textContent = text;
          loadingIndicator.style.display = isLoading ? 'flex' : 'none';
          if (isLoading) showError('');
      }
      function showError(message) {
          if (!errorMessageDiv) return;
          errorMessageDiv.textContent = message || '';
          errorMessageDiv.style.display = message ? 'block' : 'none';
      }
      function apiToJsCoords(apiCoords) {
          return apiCoords ? { lat: apiCoords.latitude, lng: apiCoords.longitude } : null;
      }

      async function loadServicesAndComponents() {
        showLoading(true, "Loading services...");
        try {
            const [mapsLib, markerLib, placesLib, coreLib, geocodingLib] = await Promise.all([
                google.maps.importLibrary("maps"),
                google.maps.importLibrary("marker"),
                google.maps.importLibrary("places"),
                google.maps.importLibrary("core"),
                google.maps.importLibrary("geocoding")
            ]);
            Map = mapsLib.Map;
            AdvancedMarkerElement = markerLib.AdvancedMarkerElement;
            PinElement = markerLib.PinElement;
            Autocomplete = placesLib.Autocomplete;
            PlaceDetailsElement = placesLib.PlaceDetailsElement; // Web component is loaded automatically
            Geocoder = geocodingLib.Geocoder;
            LatLngBounds = coreLib.LatLngBounds;

            geocoder = new Geocoder();
        } catch (error) {
            console.error("Failed to load Google Maps libraries:", error);
            showError(`Failed to load services: ${error.message}`);
            throw error; // Re-throw to stop initialization
        } finally {
            showLoading(false);
        }
      }

      async function init() {
        showLoading(true, "Initializing map...");
        try {
          await loadServicesAndComponents(); // Load libraries first
          await init2DMap();
          setupAutocomplete();
          setupPlaceDetailsWidget();

          const initialLocationResult = await geocodeSearchCenter(defaultSearchAddress);
          if (initialLocationResult && initialLocationResult.geometry?.location) {
            const location = initialLocationResult.geometry.location;
            const place_id = initialLocationResult.place_id;
            const name = initialLocationResult.formatted_address || defaultSearchAddress;
            searchOrigin = { location, placeId: place_id, name };

            map.setCenter(location);
            map.setZoom(15);
            addSearchOriginMarker(location, name);
            updateSidebarTitle(name);
            await findAndDisplayPlaces(location, name);
          } else {
            showError(`Could not find initial location: "${defaultSearchAddress}". Please search manually.`);
            map.setCenter({ lat: 37.783, lng: -122.403 });
            map.setZoom(14);
            updateSidebarTitle("San Francisco");
            sidebarSubtitle.textContent = "Could not find Moscone Center";
          }
        } catch (error) {
          console.error("Initialization failed:", error);
          showError(`Map initialization failed: ${error.message}. Check API key/Map ID or network connection.`);
        } finally {
          showLoading(false);
        }
      }

      async function init2DMap() {
        if (!Map) throw new Error("Map class not loaded.");
        if (!mapId) throw new Error("Map ID is required for 2D Vector Maps and Advanced Markers.");
        map = new Map(mapDiv, {
            center: { lat: 37.783, lng: -122.403 },
            zoom: 14,
            mapId: mapId,
            gestureHandling: "greedy",
            disableDefaultUI: true,
            zoomControl: true,
        });
        map.addListener('click', (e) => {
            if (!e.placeId) {
                hidePlaceDetailsPanel();
            }
        });
      }

      function setupAutocomplete() {
        if (!Autocomplete || !map) { console.error("Autocomplete or Map not ready."); return; }
        autocomplete = new Autocomplete(acInput, {
            fields: ["place_id", "geometry", "name", "formatted_address"],
            types: ['geocode', 'establishment']
        });
        autocomplete.bindTo("bounds", map);
        autocomplete.addListener('place_changed', handlePlaceSelection);
      }

      function setupPlaceDetailsWidget() {
          placeDetailsWidget = document.getElementById('place-details-widget');
          if (!placeDetailsWidget) {
              console.error("Place Details Widget element not found!");
          }
      }

      async function handlePlaceSelection() {
          showError('');
          hidePlaceDetailsPanel();
          if (!autocomplete) return;
          const place = autocomplete.getPlace();
          if (!place.place_id || !place.geometry?.location) {
              showError("Please select a valid place from the suggestions.");
              return;
          }
          const locationName = place.name || place.formatted_address || 'Selected Location';

          searchOrigin = { location: place.geometry.location, placeId: place.place_id, name: locationName };
          updateSidebarTitle(locationName);
          map.setCenter(searchOrigin.location);
          map.setZoom(15);
          addSearchOriginMarker(searchOrigin.location, locationName);
          await findAndDisplayPlaces(searchOrigin.location, locationName);
      }

      async function geocodeSearchCenter(address) {
        if (!geocoder) { showError("Geocoding service unavailable."); return null; }
        showLoading(true, `Geocoding "${address}"...`);
        try {
            const { results } = await geocoder.geocode({ address: address });
            if (results?.[0]) {
                return results[0];
            } else {
                return null;
            }
        } catch (e) {
            console.error("Geocode failed:", e);
            showError(`Geocoding error: ${e.message}`);
            return null;
        } finally {
            showLoading(false);
        }
      }

      async function findAndDisplayPlaces(centerLocation, locationName = "selected area") {
        showLoading(true, `Searching for ${placeTypeQuery} near ${locationName}...`);
        resultsListDiv.innerHTML = '';
        clearMarkers();
        hidePlaceDetailsPanel();

        const places = await searchNearbyPlaces(centerLocation.toJSON(), searchRadiusMeters, placeTypeQuery);

        if (!places || places.length === 0) {
          showError(`No ${placeTypeQuery} found near ${locationName}.`);
          resultsListDiv.innerHTML = '<p class="text-gray-500 p-4">No results found.</p>';
          showLoading(false);
          return;
        }

        const topRatedPlaces = places
          .filter(p => p.rating && p.rating >= 4.0 && p.userRatingCount && p.userRatingCount >= 10)
          .sort((a, b) => (b.rating || 0) - (a.rating || 0))
          .slice(0, 10);

        if (topRatedPlaces.length === 0) {
            showError(`Found ${placeTypeQuery} near ${locationName}, but none met the rating/review criteria (>= 4.0 stars, >= 10 reviews).`);
            resultsListDiv.innerHTML = '<p class="text-gray-500 p-4">No highly-rated places found matching criteria.</p>';
            showLoading(false);
            return;
        }

        if (!AdvancedMarkerElement || !LatLngBounds) { showError("Marker or Bounds class not loaded."); return; }

        const bounds = new LatLngBounds();
        if (searchOriginMarker) bounds.extend(searchOriginMarker.position);

        topRatedPlaces.forEach((place, index) => {
          const position = apiToJsCoords(place.location);
          if (!position) return;
          const marker = addPlaceMarker(position, place);
          activeMarkers.set(place.id, marker);
          bounds.extend(position);

          const listItem = createListItem(place, index + 1);
          resultsListDiv.appendChild(listItem);
        });

        if (!bounds.isEmpty()) {
            map.fitBounds(bounds, 100);
        }

        showLoading(false);
      }

      async function searchNearbyPlaces(location, radius, query) {
        const url = 'https://places.googleapis.com/v1/places:searchText';
        const headers = {
          'Content-Type': 'application/json',
          'X-Goog-Api-Key': apiKey,
          'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.location,places.rating,places.userRatingCount,places.types,places.regularOpeningHours'
        };
        const body = JSON.stringify({
            textQuery: query,
            maxResultCount: 20,
            locationBias: {
                circle: {
                    center: { latitude: location.lat, longitude: location.lng },
                    radius: radius
                }
            }
        });

        try {
          const response = await fetch(url, { method: 'POST', headers, body });
          if (!response.ok) {
            let errorDetails = response.statusText;
            try { const errorData = await response.json(); errorDetails = errorData.error?.message || JSON.stringify(errorData); } catch (e) {}
            throw new Error(`Search failed (${response.status}): ${errorDetails}`);
          }
          const data = await response.json();
          return data.places || [];
        } catch (error) {
          console.error('Search fetch error:', error);
          showError(`Search failed: ${error.message}`);
          return [];
        }
      }

      function addSearchOriginMarker(position, title) {
          if (!AdvancedMarkerElement || !PinElement || !map) { showError("Marker components or map not ready."); return; }
          if (searchOriginMarker) {
              searchOriginMarker.position = position;
              searchOriginMarker.title = `Searched Location: ${title}`;
              searchOriginMarker.map = map;
          } else {
              const pin = new PinElement({ background: "#FBBC04", borderColor: "#1967D2", glyphColor: "white" });
              searchOriginMarker = new AdvancedMarkerElement({
                  position: position, map: map, title: `Searched Location: ${title}`, content: pin.element, zIndex: 10
              });
          }
      }

      function addPlaceMarker(position, placeData) {
          if (!AdvancedMarkerElement || !map) { showError("Marker class or map not ready."); return null; }
          const placeName = placeData.displayName?.text || 'Place';
          const markerContent = document.createElement('div');
          markerContent.className = 'shop-marker-tag';
          markerContent.textContent = placeName;

          const marker = new AdvancedMarkerElement({
              position: position, map: map, title: placeName, content: markerContent, gmpClickable: true, zIndex: 1
          });
           marker.placeData = placeData; // Attach data for later use
           marker.addEventListener('gmp-click', () => handleMarkerOrListClick(placeData.id));
           return marker;
        }

       function createListItem(place, rank) {
            const item = document.createElement('div');
            item.className = 'list-item';
            item.dataset.placeId = place.id;

            let ratingHtml = '<span class="text-gray-500">No rating</span>';
            if (place.rating) {
                const ratingCount = place.userRatingCount ? ` (${place.userRatingCount})` : '';
                ratingHtml = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg><span>${place.rating.toFixed(1)}${ratingCount}</span>`;
            }
            let hoursStatusHtml = '';
            if (place.regularOpeningHours?.openNow !== undefined) {
                const isOpen = place.regularOpeningHours.openNow;
                const statusClass = isOpen ? 'text-green-600' : 'text-red-600';
                const statusText = isOpen ? 'Open Now' : 'Closed';
                hoursStatusHtml = `<span class="${statusClass} font-medium ml-2">${statusText}</span>`;
            }
            item.innerHTML = `
                <div class="rank">${rank}.</div>
                <div class="content">
                    <div class="name">${place.displayName?.text || 'Unnamed Place'}</div>
                    <div class="details">${ratingHtml}${hoursStatusHtml}</div>
                    <div class="address">${place.formattedAddress || 'Address unavailable'}</div>
                </div>`;
            item.addEventListener('click', () => handleMarkerOrListClick(place.id));
            return item;
       }

       function handleMarkerOrListClick(placeId) {
           if (!placeId || !map) return;
           const marker = activeMarkers.get(placeId);
           if (marker) {
               map.panTo(marker.position);
           }
           document.querySelectorAll('.list-item.selected').forEach(el => el.classList.remove('selected'));
           const listItem = resultsListDiv.querySelector(`[data-place-id="${placeId}"]`);
           if (listItem) {
               listItem.classList.add('selected');
               listItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
           }
           showPlaceDetailsPanel(placeId);
       }

       async function showPlaceDetailsPanel(placeId) {
           if (!placeDetailsWidget || !placeId) {
               showError("Cannot display place details.");
               return;
           }
           detailsPanel.style.display = 'flex';
           showLoading(true, "Loading place details...");
           try {
               await customElements.whenDefined('gmp-place-details'); // Ensure WC is ready
               await placeDetailsWidget.configureFromPlace({ id: placeId });
               showError('');
           } catch (error) {
               console.error(`Place Details config error for ${placeId}:`, error);
               showError(`Could not load details: ${error.message}`);
               hidePlaceDetailsPanel();
           } finally {
               showLoading(false);
           }
       }

       function hidePlaceDetailsPanel() {
           if (detailsPanel) detailsPanel.style.display = 'none';
           document.querySelectorAll('.list-item.selected').forEach(el => el.classList.remove('selected'));
       }

       function updateSidebarTitle(locationName) {
           if (sidebarTitle) sidebarTitle.textContent = `Nearby ${placeTypeQuery}`;
           if (sidebarSubtitle) sidebarSubtitle.textContent = `Near ${locationName}`;
       }

       function clearMarkers() {
           activeMarkers.forEach(marker => { marker.map = null; });
           activeMarkers.clear();
       }

      window.hidePlaceDetailsPanel = hidePlaceDetailsPanel;
      init(); // Start the application
    </script>
</body>
</html>
```

**14.1. HTML/CSS/JS Template (3D Map \+ Interactive Markers \+ Place Details UI Kit)**

* **Note:** This template uses `v=alpha`. It shows interactive 3D markers, fetches elevation, handles clicks to show details in the UI Kit panel, and flies the camera.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Markers</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
    <style>
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; }
        #map-container { height: 100%; width: 100%; position: relative; }
        #map3d-host { height: 100%; width: 100%; background-color: #333; }
        gmp-map-3d { display: block; height: 100%; width: 100%; }
        .sidebar-content::-webkit-scrollbar { width: 6px; }
        .sidebar-content::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 3px; }
        #details-panel { position: absolute; top: 1rem; right: 1rem; background: white; border-radius: 0.5rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 20; max-width: 350px; max-height: calc(100vh - 2rem); display: none; flex-direction: column; }
        #details-panel .panel-header { padding: 0.5rem 0.75rem; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center; }
        #details-panel .panel-header h3 { font-size: 0.9rem; font-weight: 600; margin: 0; }
        #details-panel .close-button { background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0.25rem; line-height: 1; }
        #details-panel .panel-content { padding: 0; overflow-y: auto; flex-grow: 1; }
        gmp-place-details { display: block; width: 100%; }
        .list-item { display: flex; align-items: center; padding: 10px 12px; border-bottom: 1px solid #e0e0e0; cursor: pointer; transition: background-color 0.15s ease-in-out; }
        .list-item:hover { background-color: #f5f5f5; }
        .list-item.selected { background-color: #e8f0fe; border-left: 4px solid #1967d2; padding-left: 8px; }
        .list-item .icon { width: 20px; height: 20px; margin-right: 10px; fill: #1A73E8; flex-shrink: 0; }
        .list-item .content { flex: 1; }
        .list-item .name { font-size: 0.9rem; font-weight: 500; color: #202124; }
        .list-item .coords { font-size: 0.75rem; color: #5f6368; }
    </style>
    <script>
      (g=>{var h,a,k,p="The Google Maps JavaScript API",c="google",l="importLibrary",q="__ib__",m=document,b=window;b=b[c]||(b[c]={});var d=b.maps||(b.maps={}),r=new Set,e=new URLSearchParams,u=()=>h||(h=new Promise(async(f,n)=>{await(a=m.createElement("script"));e.set("libraries",[...r]+"");for(k in g)e.set(k.replace(/[A-Z]/g,t=>"_"+t.toLowerCase()),g[k]);e.set("callback",c+".maps."+q);a.src=`https://maps.${c}apis.com/maps/api/js?`+e;d[q]=f;a.onerror=()=>h=n(Error(p+" could not load."));a.nonce=m.querySelector("script[nonce]")?.nonce||"";m.head.append(a)}));d[l]?console.warn(p+" only loads once. Ignoring:",g):d[l]=(f,...n)=>r.add(f)&&u().then(()=>d[l](f,...n))})({
        key: "YOUR_API_KEY", v: "alpha",
      });
    </script>
</head>
<body class="relative h-screen overflow-hidden antialiased text-gray-800">
    <div id="map-container" class="absolute inset-0 z-0">
       <div id="map3d-host"></div>
    </div>
    <aside id="sidebar" class="absolute top-3 left-3 w-72 max-w-[calc(100%-1.5rem)] bg-white rounded-lg shadow-lg z-10 flex flex-col overflow-hidden md:bottom-auto md:max-h-[calc(100%-2rem)] max-md:bottom-0 max-md:left-0 max-md:right-0 max-md:top-auto max-md:w-full max-md:max-w-full max-md:max-h-[40vh] max-md:rounded-none max-md:rounded-t-lg max-md:border-t">
        <div class="p-3 border-b flex-shrink-0">
            <h2 id="sidebar-title" class="text-lg font-semibold">3D Locations</h2>
        </div>
        <div class="sidebar-content flex-grow overflow-y-auto">
            <div id="loading-indicator" class="p-3 text-xs text-blue-600 italic hidden flex items-center gap-2">
                <svg class="animate-spin h-4 w-4 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"> <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle> <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path> </svg>
                <span id="loading-text">Loading...</span>
            </div>
            <div id="error-message" class="p-3 text-xs text-red-600 font-medium"></div>
             <div id="results-list" class="text-sm"></div>
        </div>
    </aside>
    <div id="details-panel">
         <div class="panel-header">
             <h3>Place Details</h3>
             <button class="close-button" onclick="hidePlaceDetailsPanel()">Ã—</button>
         </div>
         <div class="panel-content">
             <gmp-place-details size="medium" id="place-details-widget"></gmp-place-details>
         </div>
     </div>
    <script type="module">
      let map3d, elevator, placeDetailsWidget;
      let Map3DElement, Marker3DInteractiveElement, AltitudeMode, MapMode, PinElement, ElevationService; // Module-level variables for classes
      let activeMarkers = new Map();
      const apiKey = "YOUR_API_KEY";

      const mapHost = document.getElementById('map3d-host');
      const loadingIndicator = document.getElementById('loading-indicator');
      const loadingText = document.getElementById('loading-text');
      const errorMessageDiv = document.getElementById('error-message');
      const resultsListDiv = document.getElementById('results-list');
      const detailsPanel = document.getElementById('details-panel');

      const sampleLocations = [
          { id: 'coit_tower', name: "Coit Tower", lat: 37.8024, lng: -122.4058, placeId: "ChIJkR7T9sJ3j4AR7VTcvY4qHqs" },
          { id: 'transamerica', name: "Transamerica Pyramid", lat: 37.7952, lng: -122.4028, placeId: "ChIJ-cKlhMN9j4ARJ2f13u5ryQE" },
          { id: 'ferry_building', name: "Ferry Building", lat: 37.7955, lng: -122.3937, placeId: "ChIJH7o2ghB9j4AR05NDffk7EZg" },
          { id: 'palace_fine_arts', name: "Palace of Fine Arts", lat: 37.8020, lng: -122.4486, placeId: "ChIJ____94mAj4ARAs-440agKk8" },
          { id: 'oracle_park', name: "Oracle Park", lat: 37.7786, lng: -122.3893, placeId: "ChIJW9TQPNSAhYARlJ96jH9fQjU" }
      ];

      function showLoading(isLoading, text = "Loading...") {
          if (!loadingIndicator || !loadingText) return;
          loadingText.textContent = text;
          loadingIndicator.style.display = isLoading ? 'flex' : 'none';
          if (isLoading) showError('');
      }
      function showError(message) {
          if (!errorMessageDiv) return;
          errorMessageDiv.textContent = message || '';
          errorMessageDiv.style.display = message ? 'block' : 'none';
      }

      async function loadServicesAndComponents() {
          showLoading(true, "Loading services...");
          try {
              const [maps3dLib, markerLib, elevationLib, placesLib, coreLib] = await Promise.all([
                  google.maps.importLibrary("maps3d"),
                  google.maps.importLibrary("marker"),
                  google.maps.importLibrary("elevation"),
                  google.maps.importLibrary("places"), // Needed for PlaceDetailsElement WC
                  google.maps.importLibrary("core")    // Needed for LatLng etc. if used
              ]);
              Map3DElement = maps3dLib.Map3DElement;
              Marker3DInteractiveElement = maps3dLib.Marker3DInteractiveElement;
              AltitudeMode = maps3dLib.AltitudeMode;
              MapMode = maps3dLib.MapMode;
              PinElement = markerLib.PinElement;
              ElevationService = elevationLib.ElevationService;
              // PlaceDetailsElement is loaded automatically as a WC

              elevator = new ElevationService();
          } catch (error) {
              console.error("Failed to load Google Maps libraries:", error);
              showError(`Failed to load services: ${error.message}`);
              throw error; // Re-throw to stop initialization
          } finally {
              showLoading(false);
          }
      }

      async function init() {
        showLoading(true, "Initializing 3D map...");
        try {
          await loadServicesAndComponents();
          await init3DMap();
          setupPlaceDetailsWidget();
          await add3DMarkers();
          populateList();
        } catch (error) {
          console.error("Initialization failed:", error);
          showError(`Map initialization failed: ${error.message}. Check API key or network connection.`);
        } finally {
          showLoading(false);
        }
      }

      async function init3DMap() {
        if (!Map3DElement || !MapMode) throw new Error("3D Map components not loaded.");
        map3d = new Map3DElement({
            center: { lat: 37.795, lng: -122.42, altitude: 200 },
            range: 5000, tilt: 45, heading: -45, mode: MapMode.HYBRID,
            defaultUIDisabled: true,
        });
        mapHost.appendChild(map3d);
        map3d.addEventListener('gmp-click', (e) => {
            // Hide panel if clicking on the map base, not a marker
            if (!e.target.closest('gmp-marker-3d-interactive')) {
                 hidePlaceDetailsPanel();
            }
        });
      }

      function setupPlaceDetailsWidget() {
          placeDetailsWidget = document.getElementById('place-details-widget');
          if (!placeDetailsWidget) {
              console.error("Place Details Widget element not found!");
          }
      }

      async function getClientElevation(latLng) {
        if (!elevator) return null;
        try {
          const { results } = await elevator.getElevationForLocations({ locations: [latLng] });
          if (results?.[0]?.elevation != null) {
            return results[0].elevation;
          } else { return null; }
        } catch (e) {
          console.error("Elevation failed:", e);
          showError(`Elevation lookup error: ${e.message}`);
          return null;
        }
      }

      async function flyToLocation(targetCoords, range = 1000, tilt = 60, heading = 0, duration = 1500) {
          if (!map3d || !targetCoords) return;
          const endCamera = { center: targetCoords, range, tilt, heading };
          try {
              await map3d.flyCameraTo({ endCamera, durationMillis: duration });
          } catch (error) {
              if (error.name === 'AbortError' || error.message?.includes('interrupted')) {
                 console.log("Camera animation interrupted.");
              } else { console.error("flyCameraTo error:", error); }
          }
      }

      async function add3DMarkers() {
          showLoading(true, "Adding 3D markers...");
          if (!Marker3DInteractiveElement || !PinElement || !AltitudeMode || !map3d) {
              showError("Cannot add markers: Required components or map not loaded.");
              return;
          }

          const locations = sampleLocations.map(loc => ({ lat: loc.lat, lng: loc.lng }));
          const elevations = await getElevationsForPoints(locations);

          sampleLocations.forEach((location, index) => {
              const baseAltitude = elevations[index] ?? 10; // Use fetched elevation or default
              const position = { lat: location.lat, lng: location.lng, altitude: baseAltitude + 20 }; // Position 20m above ground

              const pin = new PinElement({ background: '#DB4437', glyphColor: '#fff', scale: 1.2 });
              const marker = new Marker3DInteractiveElement({
                  position: position,
                  altitudeMode: AltitudeMode.RELATIVE_TO_GROUND,
                  title: location.name,
              });
              marker.appendChild(pin); // Correct: Append PinElement instance
              marker.dataset.locationId = location.id;
              marker.dataset.placeId = location.placeId;

              marker.addEventListener('gmp-click', (e) => {
                  // Use currentTarget to ensure we get the marker data, even if click is on pin
                  const clickedPlaceId = e.currentTarget.dataset.placeId;
                  const clickedLocationId = e.currentTarget.dataset.locationId;
                  handleMarkerOrListClick(clickedLocationId, clickedPlaceId);
              });

              map3d.appendChild(marker);
              activeMarkers.set(location.id, marker);
          });
          showLoading(false);
      }

      async function getElevationsForPoints(locations) {
          if (!elevator || locations.length === 0) return locations.map(() => 10); // Default if no service/locations
          const batchSize = 200;
          let allElevations = [];
          for (let i = 0; i < locations.length; i += batchSize) {
              const batchLocations = locations.slice(i, i + batchSize);
              try {
                  const { results } = await elevator.getElevationForLocations({ locations: batchLocations });
                  const elevations = results.map(result => result?.elevation ?? 10); // Default to 10 if null
                  allElevations.push(...elevations);
              } catch (e) {
                  console.error(`Elevation fetch error for batch starting at index ${i}:`, e);
                  allElevations.push(...Array(batchLocations.length).fill(10)); // Fill failed batch with default
              }
          }
          return allElevations;
      }

      function populateList() {
          resultsListDiv.innerHTML = '';
          sampleLocations.forEach(location => {
              const item = createListItem(location);
              resultsListDiv.appendChild(item);
          });
      }

      function createListItem(location) {
          const item = document.createElement('div');
          item.className = 'list-item';
          item.dataset.locationId = location.id;
          item.dataset.placeId = location.placeId;

          item.innerHTML = `
              <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>
              <div class="content">
                  <div class="name">${location.name}</div>
                  <div class="coords">${location.lat.toFixed(4)}, ${location.lng.toFixed(4)}</div>
              </div>`;

          item.addEventListener('click', () => handleMarkerOrListClick(location.id, location.placeId));
          return item;
      }

      function handleMarkerOrListClick(locationId, placeId) {
          if (!locationId) return;
          const marker = activeMarkers.get(locationId);
          if (marker && map3d) {
              // Fly camera smoothly towards the marker's position
              flyToLocation(marker.position, 1000, 65, map3d.heading);
          }
          // Highlight list item
          document.querySelectorAll('.list-item.selected').forEach(el => el.classList.remove('selected'));
          const listItem = resultsListDiv.querySelector(`[data-location-id="${locationId}"]`);
          if (listItem) {
              listItem.classList.add('selected');
              listItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
          // Show details panel if a placeId is available
          if (placeId) {
              showPlaceDetailsPanel(placeId);
          } else {
              hidePlaceDetailsPanel();
              showError("No Place ID available for this location to show details.");
          }
      }

      async function showPlaceDetailsPanel(placeId) {
          if (!placeDetailsWidget || !placeId) {
              showError("Cannot display place details.");
              return;
          }
          detailsPanel.style.display = 'flex';
          showLoading(true, "Loading place details...");
          try {
              await customElements.whenDefined('gmp-place-details'); // Ensure WC is ready
              await placeDetailsWidget.configureFromPlace({ id: placeId });
              showError('');
          } catch (error) {
              console.error(`Place Details config error for ${placeId}:`, error);
              showError(`Could not load details: ${error.message}`);
              hidePlaceDetailsPanel();
          } finally {
              showLoading(false);
          }
      }

      function hidePlaceDetailsPanel() {
          if (detailsPanel) detailsPanel.style.display = 'none';
          document.querySelectorAll('.list-item.selected').forEach(el => el.classList.remove('selected'));
      }

      window.hidePlaceDetailsPanel = hidePlaceDetailsPanel; // Make globally accessible for onclick attribute
      init(); // Start the application
    </script>
</body>
</html>
```

**15\. Summary & Key Takeaways for AI**

* **Foundation:** GCP Project, Enabled APIs, Billing Account.  
* **Authentication:** API Keys MUST have **HTTP Referrer \+ API Restrictions**. (Sec 5\)  
* **Loading:** Use Inline Bootstrap Loader \+ `importLibrary()`. Use `v=alpha` for 3D/UI Kit templates. **Load libraries ONCE** during init and store classes/services in **module-level variables**. (Sec 6\)  
* **API Prioritization:** Use Modern APIs (`fetch` for Places New/Routes). Use JS lib for Autocomplete widget, Elevation, Geocoder (client-side). (Sec 2, 9, 10\)  
* **Cost Control:** **MANDATORY `X-Goog-FieldMask` (fetch) / `fields` (JS Places)**. (Sec 3\)  
* **Map Choice:** `Map` (2D, requires `mapId`) vs `Map3DElement` (3D, `v=alpha`, altitude). (Sec 7\)  
* **Place Details Display:** **PREFER `PlaceDetailsElement` (`v=alpha`)** for standard details UI (used in Sec 14 & 14.1 templates). Use `InfoWindow` only for custom content. (Sec 8.3, 9.1, 11\)  
* **Markers:** Use `AdvancedMarkerElement` (2D) / `Marker3DInteractiveElement` (3D). Handle position, content, altitude (3D), clicks correctly. For 3D markers with `PinElement`, use `marker.appendChild(pin)`. (Sec 8.1)  
* **Coordinates:** **CRITICAL:** Convert between `{lat, lng}`, `{latitude, longitude}`. Use `ElevationService` for 3D altitude. (Sec 3, 9.3)  
* **Error Handling:** Use `try...catch`, check `response.ok`, provide user feedback (`showError`).  
* **UI:** Link list/map via IDs. Use loading/error indicators. Manage state (`activeMarkers`). Use `flyToLocation` for 3D camera. (Sec 13, 14, 14.1)  
* **NO COMMENTS:** The final generated `index.html` **MUST NOT** contain any code comments.